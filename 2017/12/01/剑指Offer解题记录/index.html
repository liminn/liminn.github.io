<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="注：该记录中解题答案均为在牛客网进行在线编程测试时的答案记录，故未自己写测试代码。 一、链表1. 两个链表的第一个公共结点题目描述：输入两个链表，找出它们的第一个公共结点。思路：  关键点：如果两个单链表有公共的结点，那么这两个链表从某一结点开始，它们的next指针都指向同一个结点，又由于是单向链表的结点，每个结点只有一个next指针，因此从第一个公共结点开始，之后它们所有的结点都是重合的，不再出">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer解题记录">
<meta property="og:url" content="http://yoursite.com/2017/12/01/剑指Offer解题记录/index.html">
<meta property="og:site_name" content="CV Notes">
<meta property="og:description" content="注：该记录中解题答案均为在牛客网进行在线编程测试时的答案记录，故未自己写测试代码。 一、链表1. 两个链表的第一个公共结点题目描述：输入两个链表，找出它们的第一个公共结点。思路：  关键点：如果两个单链表有公共的结点，那么这两个链表从某一结点开始，它们的next指针都指向同一个结点，又由于是单向链表的结点，每个结点只有一个next指针，因此从第一个公共结点开始，之后它们所有的结点都是重合的，不再出">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-02-01T03:32:48.179Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指Offer解题记录">
<meta name="twitter:description" content="注：该记录中解题答案均为在牛客网进行在线编程测试时的答案记录，故未自己写测试代码。 一、链表1. 两个链表的第一个公共结点题目描述：输入两个链表，找出它们的第一个公共结点。思路：  关键点：如果两个单链表有公共的结点，那么这两个链表从某一结点开始，它们的next指针都指向同一个结点，又由于是单向链表的结点，每个结点只有一个next指针，因此从第一个公共结点开始，之后它们所有的结点都是重合的，不再出">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/01/剑指Offer解题记录/"/>





  <title>剑指Offer解题记录 | CV Notes</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b0787916cdccc31f574cdee20c888dd6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CV Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/01/剑指Offer解题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="min">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CV Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指Offer解题记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-01T09:19:49+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>注：该记录中解题答案均为在牛客网进行<a href="https://www.nowcoder.net/ta/coding-interviews" target="_blank" rel="noopener">在线编程测试</a>时的答案记录，故未自己写测试代码。</p>
<h1 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h1><h2 id="1-两个链表的第一个公共结点"><a href="#1-两个链表的第一个公共结点" class="headerlink" title="1. 两个链表的第一个公共结点"></a>1. 两个链表的第一个公共结点</h2><p><strong>题目描述</strong>：<br>输入两个链表，找出它们的第一个公共结点。<br><strong>思路</strong>：</p>
<ul>
<li><strong>关键点</strong>：如果两个单链表有公共的结点，那么这两个链表从某一结点开始，它们的<code>next</code>指针都指向同一个结点，又由于是单向链表的结点，每个结点只有一个<code>next</code>指针，因此<strong>从第一个公共结点开始，之后它们所有的结点都是重合的，不再出现分叉</strong>。</li>
<li><strong>思路1</strong>：<ul>
<li>对于对于链表一上的每一个结点，顺序遍历链表二上的每一个结点。</li>
<li>若第一个链表的长度为$m$，第二个链表的长度为$n$，那么时间复杂度为$O(mn)$。</li>
</ul>
</li>
<li><strong>思路2</strong>：<ul>
<li>分别把两个链表的结点放入栈里，这样两个链表的尾结点就位于两个栈的栈顶，接下来比较两个栈顶的结点是否相同。如果相同，则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的结点。</li>
<li>该思路需要用到两个辅助栈，如果链表的长度分别为$m$和$n$，那么空间复杂度是$O(m+n)$，时间复杂度是$O(m+n)$。和思路1相比，时间效率得到了提高，相当于用空间消耗换取了时间效率。</li>
</ul>
</li>
<li><p><strong>思路3</strong>：</p>
<ul>
<li>首先遍历两个链表得到它们的长度。在第二次遍历时，在较长的链表上先走若干步，接着同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。</li>
<li>与思路2相比，该思路的时间复杂度为$O(m+n)$，但不需辅助栈，因此提高了空间效率。</li>
</ul>
<a id="more"></a> 
</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x):val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pHead1==<span class="literal">nullptr</span> || pHead2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//首先遍历两个链表得到它们的长度</span></span><br><span class="line">        <span class="keyword">int</span> length1,length2;</span><br><span class="line">        length1=length2= <span class="number">0</span>;</span><br><span class="line">        ListNode* pTemp1 = pHead1;</span><br><span class="line">        ListNode* pTemp2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(pTemp1!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            length1++;</span><br><span class="line">            pTemp1 = pTemp1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pTemp2!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            length2++;</span><br><span class="line">            pTemp2 = pTemp2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在第二次遍历时，在较长的链表上先走若干步</span></span><br><span class="line">        pTemp1 = pHead1;</span><br><span class="line">        pTemp2 = pHead2;</span><br><span class="line">        <span class="keyword">if</span>(length1&gt;length2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dif = length1-length2;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;dif;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pTemp1 = pTemp1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dif = length2-length1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;dif;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pTemp2 = pTemp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接着同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点</span></span><br><span class="line">        ListNode* pResult = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(pTemp1!=<span class="literal">nullptr</span> &amp;&amp; pTemp2!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(pTemp1 == pTemp2)</span><br><span class="line">            &#123;</span><br><span class="line">            	pResult = pTemp1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pTemp1 = pTemp1-&gt;next;</span><br><span class="line">                pTemp2 = pTemp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-链表中环的入口结点"><a href="#2-链表中环的入口结点" class="headerlink" title="2. 链表中环的入口结点"></a>2. 链表中环的入口结点</h2><p><strong>题目描述</strong>：<br>一个链表中包含环，请找出该链表的环的入口结点。<br><strong>思路</strong>：</p>
<ul>
<li><strong>核心思想</strong>：假定有环且已知环的结点个数为$y$，令指针<code>pTemp1</code>从首结点开始先走$y$步，再令<code>pTemp2</code>从首结点开始同<code>pTemp1</code>一起向前走，相遇处，即为环的入口结点。</li>
<li><strong>证明</strong>：假定环的结点个数为$y$，环之前的结点个数为$x$。<code>pTemp1</code>先走$y$步，然后<code>pTemp2</code>从首结点开始同<code>pTemp1</code>一起再走$x$步，则<code>pTemp2</code>在第$(x+1)$个结点处，<code>pTemp1</code>在第$(x+y+1)$个结点处。$(x+1)$结点位置和$(x+y+1)$结点位置都是环的入口结点位置。因此，依上述核心思想的步骤，<code>pTemp1</code>与<code>pTemp2</code>定会相遇，相遇处恰好为环的入口结点。</li>
<li><strong>环的结点个数求法</strong>：首先，令一指针<code>pFast</code>一次走两步，一指针<code>pSlow</code>一次走一步，若相遇，则有环，且相遇处定在环内。然后，<code>pFast</code>不动，令一指针<code>pSlow</code>继续走且计数，当<code>pSlow</code>与<code>pFast</code>再次相遇，即得出环的结点个数。</li>
<li>注意，代码中充斥着防止指针为空的情况，繁琐但必不可少。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//通过getNumberOfLoop()获取环的结点个数，0则无环；大于0则有环</span></span><br><span class="line">        ListNode* pTemp1, *pTemp2;</span><br><span class="line">        pTemp1 = pTemp2 = pHead;</span><br><span class="line">        <span class="keyword">int</span> num = getNumberOfLoop(pHead);</span><br><span class="line">        <span class="comment">//若环结点数等于0，直接返回nullptr</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//依照核心思想执行，获取pTemp1与pTemp2相遇处指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pTemp1 = pTemp1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pTemp1!=pTemp2)</span><br><span class="line">        &#123;</span><br><span class="line">            pTemp1 = pTemp1-&gt;next;</span><br><span class="line">            pTemp2 = pTemp2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pTemp1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.令pFast一次走两步，pSlow一次走一步，若相遇，则有环，且相遇处定在环内</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        ListNode* pFast, *pSlow;</span><br><span class="line">        pFast = pSlow = pHead;</span><br><span class="line">        pFast=pFast-&gt;next;    <span class="comment">//为了下个while循环的判断条件，pFast先走一步</span></span><br><span class="line">        <span class="keyword">while</span>(pFast!=pSlow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pFast==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pFast = pFast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pFast==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pFast = pFast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pSlow==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pSlow=pSlow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pFast==<span class="literal">nullptr</span> || pSlow==<span class="literal">nullptr</span>)</span><br><span class="line">            num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2.pFast不动，令pSlow继续走且计数，当pSlow与pFast再次相遇，即得出环的结点个数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pSlow=pSlow-&gt;next; <span class="comment">//为了下个while循环的判断条件，pSlow先走一步</span></span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">while</span>(pSlow!=pFast)</span><br><span class="line">            &#123;</span><br><span class="line">                pSlow=pSlow-&gt;next;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3. 反转链表"></a>3. 反转链表</h2><p><strong>题目描述</strong>：<br>给出一个链表<code>1-&gt;2-&gt;3-&gt;nullptr</code>，这个翻转后的链表为<code>3-&gt;2-&gt;1-&gt;nullptr</code><br><strong>思路</strong>：</p>
<ul>
<li><strong>方法1</strong>：迭代实现。维护三个指针<code>pPrev</code>,<code>pCurrent</code>,<code>pNext</code>，通过迭代完成链表的反转（画图使思路清晰）：<ul>
<li>起始情况：<code>pPrev</code>为<code>nullptr</code>，<code>pCurrent</code>指向<code>pHead</code></li>
<li>终止情况：<code>pPrev</code>指向链表尾元素，<code>pCurrent</code>为<code>nullptr</code></li>
</ul>
</li>
<li><strong>方法2</strong>：递归实现。利用递归走到链表的末端，然后再更新每一个结点的<code>next</code>指针 ，实现链表的反转。</li>
<li><strong>方法3</strong>：用栈实现。将链表结点指针全部压入栈中。头指针指向链表末尾结点。将栈中结点指针反串起来，栈中最后结点指针指向<code>nullptr</code>。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：迭代实现</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pPre, *pCurrent, *pNext;</span><br><span class="line">        pPre=<span class="literal">nullptr</span>;</span><br><span class="line">        pCurrent = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pCurrent!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pNext = pCurrent-&gt;next;</span><br><span class="line">            pCurrent-&gt;next = pPre;</span><br><span class="line">            pPre = pCurrent;</span><br><span class="line">            pCurrent = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        pHead=pPre;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法2：递归实现</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果链表为空或者链表中只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">NULL</span> || pHead-&gt;next==<span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        <span class="comment">//先反转后面的链表，走到链表的末端结点，返回末端结点，作为新的头结点，保存起来</span></span><br><span class="line">        ListNode* pHeadReverse=ReverseList(pHead-&gt;next);</span><br><span class="line">        <span class="comment">//再将当前节点设置为后面节点的后续节点</span></span><br><span class="line">        pHead-&gt;next-&gt;next = pHead;</span><br><span class="line">        <span class="comment">//当前节点指向NULL</span></span><br><span class="line">        pHead-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//返回新的头结点</span></span><br><span class="line">        <span class="keyword">return</span> pHeadReverse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法3：用栈实现</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode * <span class="title">reverse</span><span class="params">(ListNode * head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">//防御性编程</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//1.将链表结点指针全部压入栈中</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; stack1;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            stack1.push(temp);</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.头指针指向链表末尾结点</span></span><br><span class="line">        temp = stack1.top();</span><br><span class="line">        head=temp;</span><br><span class="line">        <span class="comment">//3.将栈中结点指针反串起来，栈中最后结点指针指向NULL</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* pNode1 = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            <span class="keyword">if</span>(stack1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                pNode1-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* pNode2 = stack1.top();</span><br><span class="line">            pNode1-&gt;next = pNode2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-合并两个排序的链表"><a href="#4-合并两个排序的链表" class="headerlink" title="4. 合并两个排序的链表"></a>4. 合并两个排序的链表</h2><p><strong>题目</strong>：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。<br><strong>思路</strong>：</p>
<ul>
<li>依照归并排序中的<code>merge</code>函数的思想，<code>merge</code>两个链表：<ul>
<li>1.比较两个链表的头结点，较小的作为新链表的头结点<code>pHeadNew</code>；</li>
<li>2.归并两个链表，迭代比较，较小者作为新的尾结点<code>pTailNew</code>。</li>
<li>注意，直接改动每一结点的<code>next</code>指针，故不需另外的辅助空间。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//防御性编程：若输入链表有任一为空，返回另一个</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        <span class="comment">//1.找出新链表的头结点pHeadNew</span></span><br><span class="line">        ListNode* pHeadNew = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pTemp1 = pHead1;</span><br><span class="line">        ListNode* pTemp2 = pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pTemp1-&gt;val &lt; pTemp2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pHeadNew = pTemp1;</span><br><span class="line">            pTemp1 = pTemp1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHeadNew = pTemp2;</span><br><span class="line">            pTemp2 = pTemp2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.归并两个链表，迭代比较，较小者作为新的尾结点pTailNew</span></span><br><span class="line">        <span class="comment">//直接改动每一结点的next指针，故不需另外的辅助空间</span></span><br><span class="line">        ListNode* pTailNew = pHeadNew; </span><br><span class="line">        <span class="keyword">while</span>(pTemp1!=<span class="literal">nullptr</span> &amp;&amp; pTemp2!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pTemp1-&gt;val &lt; pTemp2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pTailNew-&gt;next = pTemp1;</span><br><span class="line">                pTailNew = pTemp1;</span><br><span class="line">                pTemp1 = pTemp1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pTailNew-&gt;next = pTemp2;</span><br><span class="line">                pTailNew = pTemp2;</span><br><span class="line">                pTemp2 = pTemp2-&gt;next;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pTemp1!=<span class="literal">nullptr</span>) pTailNew-&gt;next = pTemp1;</span><br><span class="line">        <span class="keyword">if</span>(pTemp2!=<span class="literal">nullptr</span>) pTailNew-&gt;next = pTemp2;</span><br><span class="line">        <span class="keyword">return</span> pHeadNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-从尾到头打印链表"><a href="#5-从尾到头打印链表" class="headerlink" title="5. 从尾到头打印链表"></a>5. 从尾到头打印链表</h2><p><strong>题目描述</strong>：<br>输入一个链表的头结点，从尾到头反过来打印出每个结点的值。<br><strong>思路</strong>：</p>
<ul>
<li>首先，假定不能改变链表结构，故不采用迭代反转链表，然后后再打印链表的方法。</li>
<li><strong>方法1</strong>：遍历的顺序是从头到尾，输出的顺序是从尾到头，是典型的“后进先出”，用栈实现这种顺序：<ul>
<li>遍历链表，每经过一个结点的时候，把该结点压入辅助栈中。</li>
<li>当遍历完整个链表后，再从栈顶开始逐个输出结点的值。</li>
</ul>
</li>
<li><strong>方法2</strong>：用递归方法反向打印链表。既然可以用栈实现，而递归本质上就是一个栈结构，故可用递归来实现：<ul>
<li>每访问到一个结点，先递归输出它后面的结点，再输出该结点自身，这样链表的输出结果就反过来了。</li>
</ul>
</li>
<li>注意，虽然基于递归的代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一些（存放于自由存储的堆区）。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;    </span><br><span class="line">    <span class="built_in">stack</span>&lt;ListNode*&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* pHead) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">//遍历链表，每经过一个结点的时候，把该结点压入辅助栈中</span></span><br><span class="line">        ListNode* pTemp = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pTemp!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(pTemp);</span><br><span class="line">            pTemp = pTemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当遍历完整个链表后，再从栈顶开始逐个输出结点的值</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pTemp = s.top();</span><br><span class="line">            result.push_back(pTemp-&gt;val);</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* pHead) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        printListFromTailToHead(pHead-&gt;next);</span><br><span class="line">        result.push_back(pHead-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-复杂链表的复制"><a href="#6-复杂链表的复制" class="headerlink" title="6. 复杂链表的复制"></a>6. 复杂链表的复制</h2><p><strong>题目描述</strong><br>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<br><strong>思路</strong>：</p>
<ul>
<li><strong>步骤1</strong>：复制原始链表的任意结点$N$并创建新结点$N’$，再把$N’$链接到$N$的后面。如原来是<code>A-&gt;B-&gt;C</code>，则变成<code>A-&gt;A&#39;-&gt;B-&gt;B&#39;-&gt;C-&gt;C&#39;</code>。</li>
<li><strong>步骤2</strong>：设置复制出来的结点的<code>random</code>指针。如果原始链表上的结点$N$的<code>random</code>指针指向$S$，则它对应的复制结点$N’$的<code>ramdon</code>指针指向$S$的复制结点$S’$。如<code>A1-&gt;random = A-&gt;random-&gt;next;</code></li>
<li><strong>步骤3</strong>：把长链表拆分成两个链表：把奇数位置的结点用<code>next</code>指针链接起来就是原始链表，把偶数位置的结点用<code>next</code>指针链接起来就是复制出来的链表。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        RandomListNode* pCurrent = pHead;</span><br><span class="line">        <span class="comment">//1.复制原始链表的任一节点N并创建新节点N'，再把N'链接到N的后边</span></span><br><span class="line">        <span class="keyword">while</span>(pCurrent!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* pClone = <span class="keyword">new</span> RandomListNode(pCurrent-&gt;label);</span><br><span class="line">            pClone-&gt;next = pCurrent-&gt;next;</span><br><span class="line">            pCurrent-&gt;next = pClone;</span><br><span class="line">            pCurrent = pClone-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.如果原始链表上的节点N的random指向S，则对应的复制节点N'的random指向S的下一个节点S'</span></span><br><span class="line">        pCurrent = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pCurrent!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* pClone = pCurrent-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pCurrent-&gt;random!=<span class="literal">nullptr</span>)</span><br><span class="line">                pClone-&gt;random = pCurrent-&gt;random-&gt;next;</span><br><span class="line">            pCurrent = pClone-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.把得到的链表拆成两个链表，奇数位置上的结点组成原始链表，偶数位置上的结点组成复制出来的链表</span></span><br><span class="line">        RandomListNode* pCloneHead=pHead-&gt;next;</span><br><span class="line">        pCurrent = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pCurrent!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            RandomListNode* pClone = pCurrent-&gt;next;</span><br><span class="line">            pCurrent-&gt;next = pClone-&gt;next;</span><br><span class="line">            pCurrent = pCurrent-&gt;next;</span><br><span class="line">            <span class="comment">//pCurrent为nullptr，即pClone-&gt;next为nullptr，不用再继续，拆分结束。</span></span><br><span class="line">            <span class="keyword">if</span>(pCurrent==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pClone-&gt;next = pCurrent-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-链表中倒数第k个结点"><a href="#7-链表中倒数第k个结点" class="headerlink" title="7. 链表中倒数第k个结点"></a>7. 链表中倒数第k个结点</h2><p><strong>题目</strong>：<br>输入一个链表，输出该链表中倒数第$k$个结点。本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。<br><strong>思路</strong>：</p>
<ul>
<li>递归遍历链表，返回时通过<code>count</code>计数，当<code>count==k</code>时，当前<code>pHead</code>即为倒数第$K$个结点。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x):val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    ListNode* pTarget=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Find(pHead,k);</span><br><span class="line">        <span class="keyword">return</span> pTarget;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(ListNode* pHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Find(pHead-&gt;next,k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count==k)</span><br><span class="line">            pTarget = pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-删除链表中的重复结点"><a href="#8-删除链表中的重复结点" class="headerlink" title="8. 删除链表中的重复结点"></a>8. 删除链表中的重复结点</h2><p><strong>题目</strong>：<br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表<code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>，处理后为<code>1-&gt;2-&gt;5</code><br><strong>思路</strong>：</p>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 只有0个或1个结点，则返回</span></span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span> || pHead-&gt;next==<span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* pNext = pHead-&gt;next;</span><br><span class="line">        <span class="comment">// 当前结点是重复结点</span></span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;val == pNext-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点</span></span><br><span class="line">            <span class="keyword">while</span>(pNext!=<span class="literal">nullptr</span> &amp;&amp; pNext-&gt;val==pHead-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pNext = pNext-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从第一个与当前结点不同的结点开始递归</span></span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(pNext);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 当前结点不是重复结点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 保留当前结点，从下一个结点开始递归</span></span><br><span class="line">            pHead-&gt;next = deleteDuplication(pHead-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二、栈和队列"><a href="#二、栈和队列" class="headerlink" title="二、栈和队列"></a>二、栈和队列</h1><h2 id="1-用两个栈实现队列"><a href="#1-用两个栈实现队列" class="headerlink" title="1. 用两个栈实现队列"></a>1. 用两个栈实现队列</h2><p><strong>题目</strong>：用两个栈来实现一个队列，完成队列的<code>push</code>和<code>pop</code>操作。队列中的元素为<code>int</code>类型。<br><strong>思路</strong>：</p>
<ul>
<li>栈是后进先出，队列是先进先出。</li>
<li>利用栈<code>stack1</code>负责<code>push</code>操作。</li>
<li>利用栈<code>stack2</code>负责<code>pop</code>操作：先将<code>stack1</code>中所有元素弹出到<code>stack2</code>中，然后<code>stack2</code>出栈一个元素，最后<code>stack2</code>中所有元素弹出到<code>stack1</code>。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//利用栈stack1负责入栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用栈stack2负责出栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//先将stack1中所有元素弹出到stack2中</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack1.top();</span><br><span class="line">            stack2.push(temp);</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后stack2出栈一个元素</span></span><br><span class="line">        <span class="keyword">int</span> result = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="comment">//最后stack2中所有元素弹出到stack1</span></span><br><span class="line">        <span class="keyword">while</span>(!stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack2.top();</span><br><span class="line">            stack1.push(temp);</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-包含min函数的栈"><a href="#2-包含min函数的栈" class="headerlink" title="2. 包含min函数的栈"></a>2. 包含min函数的栈</h2><p><strong>题目</strong>：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的<code>min</code>函数。在该栈中，调用<code>min</code>、<code>push</code>及<code>pop</code>的时间复杂度都是$O(1)$。<br><strong>思路</strong>：</p>
<ul>
<li>题目要求的是栈在进行任何的入栈和出栈操作后，都能调用<code>min</code>函数返回最小值。两种思路不可行：<ul>
<li>定义一个变量<code>value</code>存储最小值。因为栈一旦<code>pop</code>后，不知道最小值是什么。</li>
<li>每次进栈出栈都重新对栈内元素进行排序。因为复杂度太高。</li>
</ul>
</li>
<li>正确解法：采用一个辅助栈，其栈顶保存主栈当前的最小值。主栈每一次<code>push</code>，辅助栈都将主栈当前的最小值压入栈顶。主栈每一次<code>pop</code>，辅助栈都<code>pop</code>。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1; <span class="comment">//主栈</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//主栈stack1每一次push，辅助栈stack2都将主栈当前的最小值压入栈顶</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            s1.push(value);</span><br><span class="line">            s2.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value&lt;s2.top())</span><br><span class="line">        &#123;</span><br><span class="line">            s1.push(value);</span><br><span class="line">            s2.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s1.push(value);</span><br><span class="line">            s2.push(s2.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主栈stack1每一次pop，辅助栈stack2都pop</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-栈的压入、弹出序列"><a href="#3-栈的压入、弹出序列" class="headerlink" title="3. 栈的压入、弹出序列"></a>3. 栈的压入、弹出序列</h2><p><strong>题目描述</strong><br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列$1,2,3,4,5$是某栈的压入顺序，序列$4,5,3,2,1$是该压栈序列对应的一个弹出序列，但$4,3,5,1,2$就不可能是该压栈序列的弹出序列。<br><strong>思路</strong>：</p>
<ul>
<li>判断一个序列是不是栈的弹出序列的规律：<ul>
<li>如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；</li>
<li>如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈为止；</li>
<li>如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.size()==<span class="number">0</span> || popV.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//标记pushV</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>; <span class="comment">//标记popV</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;pushV.size())</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(pushV[i++]);</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top()==popV[j])</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h1><h2 id="1-二叉树的深度"><a href="#1-二叉树的深度" class="headerlink" title="1. 二叉树的深度"></a>1. 二叉树的深度</h2><p><strong>题目描述</strong>:<br>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><strong>思路</strong>：<br><strong>解法1</strong>：</p>
<ul>
<li>前序遍历二叉树，计算每一叶结点的深度，找出最大的叶结点的深度，即树的高度。</li>
<li>在两种情况下，当前深度变量<code>currentDepth</code>进行减一操作：<ul>
<li>当前结点是叶结点，则将<code>currentDepth</code>与最大的叶结点深度<code>maxDepth</code>比较，更新<code>maxDepth</code>。之后，<code>currentDepth</code>进行减一操作；</li>
<li>任一结点的左右子树遍历完成，<code>currentDepth</code>进行减一操作。</li>
</ul>
</li>
<li>注：该题规定空树深度为0，根结点深度为1。</li>
</ul>
<p><strong>解法2</strong>：</p>
<ul>
<li>将结点的深度从该角度计算：后序遍历时，结点的左右子树的深度较大值加一。</li>
<li>因此，树的深度可以这样计算：后序遍历二叉树，较大子树的深度值加一。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maxDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currentDepth=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> maxDepth;</span><br><span class="line">        currentDepth++;</span><br><span class="line">        <span class="comment">//当前结点是叶结点</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left==<span class="literal">nullptr</span> &amp;&amp; pRoot-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新maxDepth</span></span><br><span class="line">            <span class="keyword">if</span>(currentDepth&gt;maxDepth)</span><br><span class="line">            &#123;</span><br><span class="line">                maxDepth = currentDepth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//currentDepth进行减一操作</span></span><br><span class="line">            currentDepth--;</span><br><span class="line">            <span class="keyword">return</span> maxDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeDepth(pRoot-&gt;left);</span><br><span class="line">        TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="comment">//任一结点的左右子树遍历完成，currentDepth进行减一操作</span></span><br><span class="line">        currentDepth--;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//递归后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口条件：若pRoot为nullptr，则返回0</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> left=TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="comment">//较大子树的深度值加一</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-二叉树的镜像"><a href="#2-二叉树的镜像" class="headerlink" title="2. 二叉树的镜像"></a>2. 二叉树的镜像</h2><p><strong>题目描述</strong>:<br>操作给定的二叉树，将其变换为源二叉树的镜像。<br><strong>输入描述</strong>:<br>二叉树的镜像定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	5  7 9  11</span><br><span class="line">镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	11 9 7   5</span><br></pre></td></tr></table></figure></p>
<p><strong>思路</strong>：</p>
<ul>
<li>前序遍历二叉树，“访问”操作为：交换每一结点的左右子树（左右子树是<code>nullptr</code>也没关系，照样交换）。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//交换左右子树</span></span><br><span class="line">        TreeNode* temp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = temp;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-平衡二叉树"><a href="#3-平衡二叉树" class="headerlink" title="3. 平衡二叉树"></a>3. 平衡二叉树</h2><p><strong>题目描述</strong><br>输入一棵二叉树，判断该二叉树是否是平衡二叉树。注意，空树默认为平衡二叉树。<br><strong>思路</strong>：</p>
<ul>
<li>依据#1题&lt;二叉树的深度&gt;中解法2的思想，将平衡二叉树的判断准则定为：每一结点的左右子树的深度值相差不超过1。</li>
<li>后序遍历二叉树，计算每一结点的左右子树的深度，比较差值。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> result=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        TreeDepth(pRoot);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历二叉树，计算树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="comment">//比较左右子树深度的差值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>)</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//计算每一结点的左右子树的深度</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-把二叉树打印成多行"><a href="#4-把二叉树打印成多行" class="headerlink" title="4. 把二叉树打印成多行"></a>4. 把二叉树打印成多行</h2><p><strong>题目描述</strong>：<br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br><strong>思路</strong>：</p>
<ul>
<li>层序遍历二叉树，在每一层末尾加入一个换行符。</li>
<li>通过变量<code>toBePrinted</code>记录当前层要打印结点个数,<code>nextLevel</code>记录下一层要打印结点个数。</li>
<li>对于根结点，<code>toBePrinted</code>为1，在将根结点的左右子结点入队时记录<code>nextLevel</code>。</li>
<li>当<code>toBePrinted</code>为0，则打印一个换行，<code>toBePrinted</code>置为<code>nextLevel</code>，<code>nextLevel</code>清零。接着，开始处理下一层。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> toBePrinted=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextLevel = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Print(TreeNode* pRoot) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        q.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* pCurrent = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            toBePrinted--;</span><br><span class="line">            level.push_back(pCurrent-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(pCurrent-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(pCurrent-&gt;left);</span><br><span class="line">                nextLevel++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pCurrent-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(pCurrent-&gt;right);</span><br><span class="line">                nextLevel++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(toBePrinted==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                toBePrinted=nextLevel;</span><br><span class="line">                nextLevel=<span class="number">0</span>;</span><br><span class="line">                result.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">//注意，最后要return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-对称的二叉树"><a href="#5-对称的二叉树" class="headerlink" title="5. 对称的二叉树"></a>5. 对称的二叉树</h2><p><strong>题目描述</strong>:<br>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br><strong>思路</strong>：</p>
<ul>
<li>一开始的想法：构建该二叉树的镜像二叉树，然后同时遍历两个树，逐一进行比较。但空间复杂度为$O(n)$，不可行。</li>
<li>正确解法：前序遍历是<code>&lt;root&gt;&lt;left&gt;&lt;right&gt;</code>。定义一种新的和前序遍历对称的遍历方式<code>&lt;root&gt;&lt;right&gt;&lt;left&gt;</code>。对于对称的二叉树，前序遍历的结果，和新定义的遍历方式的结果应该是一样的。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> treversal(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">treversal</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">nullptr</span> &amp;&amp; pRoot2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">nullptr</span> || pRoot2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val!=pRoot2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> result1=treversal(pRoot1-&gt;left, pRoot2-&gt;right);</span><br><span class="line">        <span class="keyword">bool</span> result2=treversal(pRoot1-&gt;right, pRoot2-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> result1 &amp;&amp; result2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-二叉树的下一个结点"><a href="#6-二叉树的下一个结点" class="headerlink" title="6. 二叉树的下一个结点"></a>6. 二叉树的下一个结点</h2><p><strong>题目描述</strong>:<br>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，<strong>同时包含指向父结点的指针</strong>。<br><strong>思路</strong>：</p>
<ul>
<li>在中序遍历顺序<code>&lt;left，root，right&gt;</code>下，二叉树某一结点<code>pNode</code>的下一个结点规律如下：<ul>
<li>如果<code>pNode</code>含有右子树，则下一结点为<code>pNode</code>的<strong>右子树中最深最左的那个结点</strong>。</li>
<li>如果<code>pNode</code>不含右子树，则下一结点为<strong>使得<code>pNode</code>在其左子树中的最近的祖先结点</strong>。<br>注：最极端情况是<code>pNode</code>是二叉树中序遍历的最后一个结点，即在二叉树的最右末端，直到回溯到根结点，<code>pNode</code>还是在右子树中，即没有满足题意的下一结点。根结点的父节点为<code>nullptr</code>，祖先结点为<code>nullptr</code>也是终止循环条件之一。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeLinkNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *right;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *next;</span></span><br><span class="line"><span class="comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeLinkNode* pNext=<span class="literal">nullptr</span>; <span class="comment">//记录目标结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//如果pNode含有右子树，则下一结点为pNode的右子树中最深最左的那个结点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pNext=pNode-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(pNext-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pNext=pNext-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pNode不含右子树，则下一结点为使得pNode在其左子树中的最近的祖先结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeLinkNode* pParent = pNode-&gt;next;</span><br><span class="line">            <span class="comment">//最极端情况：若到根节点还没找到</span></span><br><span class="line">            <span class="keyword">while</span>(pParent!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pParent-&gt;left==pNode)</span><br><span class="line">                &#123;</span><br><span class="line">                    pNext=pParent;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pNode = pParent;</span><br><span class="line">                    pParent=pParent-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-二叉搜索树与双向链表"><a href="#7-二叉搜索树与双向链表" class="headerlink" title="7. 二叉搜索树与双向链表"></a>7. 二叉搜索树与双向链表</h2><p><strong>题目描述</strong>：<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><strong>思路</strong>：</p>
<ul>
<li>首先，二叉搜索树的中序遍历结果即为有序序列。</li>
<li>然后，在中序遍历的“访问”操作中进行如下操作完成双向链表的转换：<ul>
<li>维护双向链表的尾结点<code>pLastNode</code>，初始化为<code>nullptr</code>。 </li>
<li>当前结点的<code>left</code>指针指向<code>pLastNode</code>，<code>pLastNode</code>的<code>right</code>指针指向当前结点，更新<code>pLastNode</code>。</li>
<li>最终结果： <code>nullptr&lt;-1&lt;=&gt;2&lt;=&gt;3&lt;=&gt;4&lt;=&gt;5-&gt;nullptr</code>（自己画图即可知）。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//pLastNode表示双向链表中的最后一个结点</span></span><br><span class="line">        TreeNode* pLastNode=<span class="literal">nullptr</span>;</span><br><span class="line">        InorderTraversal(pRoot,&amp;pLastNode);</span><br><span class="line">        TreeNode* pHead=pLastNode;</span><br><span class="line">        <span class="comment">//找出双向链表中的头结点，并返回</span></span><br><span class="line">        <span class="keyword">while</span>(pHead-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pHead=pHead-&gt;left;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">(TreeNode* pRoot,TreeNode** pLastNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        InorderTraversal(pRoot-&gt;left,pLastNode);</span><br><span class="line">        <span class="comment">//如果pLastNode为nullptr</span></span><br><span class="line">        <span class="keyword">if</span>(*pLastNode==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pRoot-&gt;left=*pLastNode;     <span class="comment">//当前结点的left指针指向链表中最后一个结点</span></span><br><span class="line">            *pLastNode=pRoot;           <span class="comment">//更新链表中最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pRoot-&gt;left=*pLastNode;     <span class="comment">//当前结点的left指针指向链表中最后一个结点</span></span><br><span class="line">            (*pLastNode)-&gt;right=pRoot;  <span class="comment">//链表中最后一个结点的right指针指向当前结点</span></span><br><span class="line">            *pLastNode=pRoot;           <span class="comment">//更新链表中最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        InorderTraversal(pRoot-&gt;right,pLastNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-从上往下打印二叉树"><a href="#8-从上往下打印二叉树" class="headerlink" title="8. 从上往下打印二叉树"></a>8. 从上往下打印二叉树</h2><p><strong>题目描述</strong>:<br>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br><strong>思路</strong>：</p>
<ul>
<li>层序遍历二叉树。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* pCurrent = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            v.push_back(pCurrent-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(pCurrent-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                q.push(pCurrent-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(pCurrent-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                q.push(pCurrent-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="9-二叉树中和为某一值的路径"><a href="#9-二叉树中和为某一值的路径" class="headerlink" title="9. 二叉树中和为某一值的路径"></a>9. 二叉树中和为某一值的路径</h2><p><strong>题目描述</strong>:<br>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br><strong>思路</strong>：</p>
<ul>
<li>前序遍历二叉树，计算每一路径和，与期望值进行比较。</li>
<li>在两种情况下，从当前状态存储变量（<code>currentSum</code>及 <code>path</code>）中移去当前结点：<ul>
<li>当前结点是叶结点，则将路径和与期望数值比较之后，从当前状态存储变量中移去当前结点(<code>path.pop_back()</code>,<code>currentSum-=root-&gt;val</code>)；</li>
<li>任一结点的左右子树遍历完成,从当前状态存储变量中移去当前结点(<code>path.pop_back()</code>,<code>currentSum-=root-&gt;val</code>)。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> currentSum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        preOrder(root,expectNumber);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历二叉树，计算每一路径和。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root, <span class="keyword">int</span> expectNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        currentSum+=root-&gt;val;</span><br><span class="line">        <span class="comment">//1.当前结点是叶结点，则将路径和与期望数值比较之后，从当前状态存储变量中移去当前结点；</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(currentSum==expectNumber)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下面该段可都不写，都留给情况2去处理，但若写，就需要return，否则会处理两次。</span></span><br><span class="line">            <span class="keyword">if</span>(path.size()&gt;<span class="number">0</span>)</span><br><span class="line">                path.pop_back();</span><br><span class="line">            currentSum-=root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//注意，需要return</span></span><br><span class="line">        &#125;</span><br><span class="line">        preOrder(root-&gt;left,expectNumber);</span><br><span class="line">        preOrder(root-&gt;right,expectNumber);</span><br><span class="line">        <span class="comment">//2.任一结点的左右子树遍历完成,从当前状态存储变量中移去当前结点。</span></span><br><span class="line">        currentSum-=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(path.size()&gt;<span class="number">0</span>)</span><br><span class="line">            path.pop_back();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="10-按之字形顺序打印二叉树"><a href="#10-按之字形顺序打印二叉树" class="headerlink" title="10. 按之字形顺序打印二叉树"></a>10. 按之字形顺序打印二叉树</h2><p><strong>题目描述</strong>：<br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><strong>思路</strong>：</p>
<ul>
<li>按之字形顺序打印二叉树需要两个栈。</li>
<li>若当前打印的是奇数层（如第1层、第3层），则先保存左子节点再保存右子节点到第一个栈。</li>
<li>若当前打印的是偶数层（如第2层、第4层），则先保存右子节点再保存左子节点到第二个栈。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Print(TreeNode* pRoot) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        s1.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty()||!s2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!s1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* pTemp = s1.top();</span><br><span class="line">                    s1.pop();</span><br><span class="line">                    level.push_back(pTemp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(pTemp-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                        s2.push(pTemp-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(pTemp-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                        s2.push(pTemp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s2.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!s2.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* pTemp = s2.top();</span><br><span class="line">                    s2.pop();</span><br><span class="line">                    level.push_back(pTemp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(pTemp-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                        s1.push(pTemp-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(pTemp-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                        s1.push(pTemp-&gt;left);                 </span><br><span class="line">                &#125;</span><br><span class="line">                result.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="11-二叉搜索树的第k个结点"><a href="#11-二叉搜索树的第k个结点" class="headerlink" title="11. 二叉搜索树的第k个结点"></a>11. 二叉搜索树的第k个结点</h2><p><strong>题目描述</strong>:<br>给定一颗二叉搜索树，请找出其中的第$k$大的结点。例如， 5 / \ 3 7 / \ / \ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。<br><strong>思路</strong>：</p>
<ul>
<li>中序遍历BST可得有序序列。</li>
<li>在中序遍历的“访问”操作中计数。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    TreeNode* pNode=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        KthNode(pRoot-&gt;left,k);</span><br><span class="line">        <span class="comment">//在“访问”操作中计数</span></span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span>(num==k)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode=pRoot; </span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        KthNode(pRoot-&gt;right,k);</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="12-二叉搜索树的后序遍历序列"><a href="#12-二叉搜索树的后序遍历序列" class="headerlink" title="12. 二叉搜索树的后序遍历序列"></a>12. 二叉搜索树的后序遍历序列</h2><p><strong>题目描述</strong>：<br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><strong>思路</strong>：</p>
<ul>
<li>后序遍历顺序：<code>&lt;left，right，root&gt;</code>。</li>
<li>对于二叉搜索树的后续遍历序列，如果去掉最后一个元素x（也就是根）的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。</li>
<li>故以该规律，递归验证每一左右子树。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Check(sequence,<span class="number">0</span>,sequence.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口条件1：一个或零个元素，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> rootVal = sequence[end];</span><br><span class="line">        <span class="comment">//分出左子树</span></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;rootVal)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//验证右子树中所有元素都大于root值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;end;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//递归出口条件2：右子树中存在小于root值的元素</span></span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;rootVal)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归验证左右子树，需都返回true</span></span><br><span class="line">        <span class="keyword">bool</span> result1 = Check(sequence,start,i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">bool</span> result2 = Check(sequence,i,end<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> result1 &amp;&amp; result2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="13-树的子结构"><a href="#13-树的子结构" class="headerlink" title="13. 树的子结构"></a>13. 树的子结构</h2><p><strong>题目描述</strong>:<br>输入两棵二叉树A，B，判断B是不是A的子结构。此外，约定空树不是任意一个树的子结构。<br><strong>思路</strong>：</p>
<ul>
<li>遍历树A，在树A中找出所有与树B的根节点值相等的结点，保存至vector容器<code>v</code>中。</li>
<li>函数<code>bool Check(TreeNode* pTest, TreeNode* pRoot2)</code>：检验以<code>pTest</code>为根结点的树是否包含树B。<strong>注意，左右子树都需返回<code>true</code></strong>。</li>
<li>对于容器<code>v</code>中所有的<code>pTest</code>结点，逐一进行检验，<strong>只要有一个成立即可</strong>，即包含。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">nullptr</span> || pRoot2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//在树A中找出所有与树B的根节点值相等的结点，保存至容器v中</span></span><br><span class="line">        Find(pRoot1,pRoot2);</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//对于容器v中所有的pTest结点，逐一进行检验</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;v.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result = Check(v[i],pRoot2);</span><br><span class="line">            <span class="comment">//只要有一个成立即可，即包含</span></span><br><span class="line">            <span class="keyword">if</span>(result==<span class="literal">true</span>) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val==pRoot2-&gt;val)</span><br><span class="line">            v.push_back(pRoot1);</span><br><span class="line">        Find(pRoot1-&gt;left,pRoot2);</span><br><span class="line">        Find(pRoot1-&gt;right,pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(TreeNode* pTest, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pTest==<span class="literal">nullptr</span> &amp;&amp; pRoot2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pTest==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pTest-&gt;val!=pRoot2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> result1 = Check(pTest-&gt;left,pRoot2-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> result2 = Check(pTest-&gt;right,pRoot2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> result1 &amp;&amp; result2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="14-重建二叉树"><a href="#14-重建二叉树" class="headerlink" title="14. 重建二叉树"></a>14. 重建二叉树</h2><p><strong>题目描述</strong>:<br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列<script type="math/tex">\{1,2,4,7,3,5,6,8\}</script>和中序遍历序列<script type="math/tex">\{4,7,2,1,5,3,8,6\}</script>，则重建二叉树并返回。<br><strong>思路</strong>：</p>
<ul>
<li>首先，前序遍历序列的首元素给出根结点；然后，通过中序遍历序列得出左右子树长度；最后，可分割出左右子树各自的前序序列和中序序列。</li>
<li>分别递归重建左子树和右子树，递归终止条件：<ul>
<li>当序列中只剩一元素(<code>start==end</code>)时，返回该根结点指针；</li>
<li>当序列中无元素(<code>start&gt;end</code>)时，返回<code>nullptr</code>。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.empty() || vin.empty() || pre.size()!=vin.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> reConstruct(pre, <span class="number">0</span>, pre.size()<span class="number">-1</span>,vin,<span class="number">0</span>, vin.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstruct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin,<span class="keyword">int</span> vinStart, <span class="keyword">int</span> vinEnd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口条件1：当序列中只剩一结点，返回该结点指针</span></span><br><span class="line">        <span class="keyword">if</span>(preStart==preEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* pNode = <span class="keyword">new</span> TreeNode(pre[preStart]);</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归出口条件2：当序列无结点时，返回nullptr</span></span><br><span class="line">        <span class="keyword">if</span>(preStart&gt;preEnd)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//前序遍历序列的首元素给出根结点</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[preStart];</span><br><span class="line">        TreeNode* pRoot = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">//通过中序遍历序列得出左右子树长度</span></span><br><span class="line">        <span class="keyword">int</span> i = vinStart;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;vinEnd;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i]==rootVal)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftLength = i-vinStart; <span class="keyword">int</span> rightLength = vinEnd-i;</span><br><span class="line">        <span class="comment">//分割出左右子树各自的前序序列和中序序列</span></span><br><span class="line">        <span class="keyword">int</span> preStartLeft = preStart+<span class="number">1</span>;<span class="keyword">int</span> preEndLeft=preStartLeft+leftLength<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> vinStartLeft=vinStart;<span class="keyword">int</span> vinEndLeft=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> preStartRight = preEndLeft+<span class="number">1</span>;<span class="keyword">int</span> preEndRight=preEnd;</span><br><span class="line">        <span class="keyword">int</span> vinStartRight = i+<span class="number">1</span>;<span class="keyword">int</span> vinEndRight=vinEnd;</span><br><span class="line">        <span class="comment">//分别递归重建左子树和右子树</span></span><br><span class="line">        pRoot-&gt;left = reConstruct(pre,preStartLeft,preEndLeft,vin,vinStartLeft,vinEndLeft);</span><br><span class="line">        pRoot-&gt;right =reConstruct(pre,preStartRight,preEndRight,vin,vinStartRight,vinEndRight);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="15-序列化二叉树"><a href="#15-序列化二叉树" class="headerlink" title="15. 序列化二叉树"></a>15. 序列化二叉树</h2><p><strong>题目描述</strong>：<br>请实现两个函数，分别用来序列化和反序列化二叉树<br><strong>思路</strong>：</p>
<ul>
<li>对于序列化：<ul>
<li>使用前序遍历，递归的将二叉树的值转化为字符，并且在每次二叉树的结点不为空时，在转化val所得的字符之后添加一个<code>&#39;，&#39;</code>作为分割。对于空节点则以 <code>&#39;#&#39;</code> 代替。</li>
</ul>
</li>
<li>对于反序列化：<ul>
<li>按照前序顺序，递归的使用字符串中的字符创建左右子树。注意：在递归时，递归函数的参数一定要是<code>char **</code>，这样才能保证每次递归后指向字符串的指针会随着递归的进行而移动。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        Serialize2(root,str);</span><br><span class="line">        <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[str.size()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">            result[i] = str[i];</span><br><span class="line">        result[str.size()] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Serialize2</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str+=<span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> r = to_string(root-&gt;val);</span><br><span class="line">        str+=r;</span><br><span class="line">        str+=<span class="string">','</span>;</span><br><span class="line">        Serialize2(root-&gt;left, str);</span><br><span class="line">        Serialize2(root-&gt;right, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* result = Deserialize2(&amp;str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize2</span><span class="params">(<span class="keyword">char</span>** str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(**str==<span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*str)++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(**str!= <span class="string">'\0'</span> &amp;&amp; **str!=<span class="string">','</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num=num*<span class="number">10</span>+((**str)-<span class="string">'0'</span>);</span><br><span class="line">            (*str)++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* pRoot = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        <span class="keyword">if</span>(**str ==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            (*str)++;</span><br><span class="line">        pRoot-&gt;left = Deserialize2(str);</span><br><span class="line">        pRoot-&gt;right= Deserialize2(str);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="1-替换空格"><a href="#1-替换空格" class="headerlink" title="1. 替换空格"></a>1. 替换空格</h2><p><strong>题目描述</strong>：<br>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为”We Are Happy.”则经过替换之后的字符串为”We%20Are%20Happy.”<br><strong>思路</strong>：</p>
<ul>
<li><strong>注意</strong>：假设在原来的字符串上进行替换，并保证输入的字符串后面有足够多的空余内存。</li>
<li><strong>步骤</strong>：从后向前替换：<ul>
<li>1.遍历字符串，得到原字符串的长度和空格的个数;</li>
<li>2.计算新字符串的长度，新串长度为原串长度加上两倍的空格个数；</li>
<li>3.从后向前替换：设置两个指针，p1指向原字符串末尾，p2指向新字符串末尾。前移指针p1，逐个把它指向的内容复制到p2指向的位置；</li>
</ul>
</li>
<li>所有字符串都只复制一次，时间复杂度：O(n)。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">nullptr</span> || length&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//1.遍历字符串，得到空格的个数</span></span><br><span class="line">        <span class="keyword">int</span> numSpace = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">                numSpace++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.计算新字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> lengthNew = length+<span class="number">2</span>*numSpace;</span><br><span class="line">        <span class="comment">//3.从后向前替换：设置两个指针，i指向原字符串末尾，j指向新字符串末尾</span></span><br><span class="line">        <span class="keyword">int</span> i = length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = lengthNew<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//终止条件，i&lt;0</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str[j--] = <span class="string">'0'</span>;</span><br><span class="line">                str[j--] = <span class="string">'2'</span>;</span><br><span class="line">                str[j--] = <span class="string">'%'</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                str[j--] = str[i--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#2-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="2. 整数中1出现的次数（从1到n整数中1出现的次数）"></a>2. 整数中1出现的次数（从1到n整数中1出现的次数）</h2><p><strong>题目描述</strong><br>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。<br><strong>思路</strong>：</p>
<ul>
<li>对1~n的每一个数：通过对10求余数判断整数的个位数字是不是1，如果这个数字大于10，则除以10之后再判断个位数字是不是1。</li>
<li>对每个数字都要做除法和求余运算，以求出该数字中1出现的次数。如果输入数字为$n$，$n$有$O(logn)$位，我们需要判断每一位是不是1，那么它的时间复杂度是$O(nlogn)$。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            number+=NumberOf1(i);</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">10</span> ==<span class="number">1</span>)</span><br><span class="line">                number++;</span><br><span class="line">            n=n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-翻转单词顺序列"><a href="#3-翻转单词顺序列" class="headerlink" title="3. 翻转单词顺序列"></a>3. 翻转单词顺序列</h2><p><strong>题目描述</strong>:输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student.”，则输出”student. a am I”。<br><strong>思路</strong>：</p>
<ul>
<li>第一步翻转句子中所有的字符。比如翻转”I am a student.”中所有的字符得到”.tenduts a ma I”，此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。</li>
<li>第二步再翻转每个单词中字符的顺序，就得到了“studnet. a am I”。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.先整体翻转</span></span><br><span class="line">        ReverseWord(str,<span class="number">0</span>,str.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> i,start,end;</span><br><span class="line">        i=start=end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;str.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//空格跳过</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;str.size() &amp;&amp; str[i]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是空格，找单词最后一个字符的位置</span></span><br><span class="line">            start = end = i;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;str.size() &amp;&amp; str[i]!=<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.局部翻转</span></span><br><span class="line">            ReverseWord(str,start,end<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReverseWord</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(str[start++],str[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-左旋转字符串"><a href="#4-左旋转字符串" class="headerlink" title="4. 左旋转字符串"></a>4. 左旋转字符串</h2><p><strong>题目描述</strong><br>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！<br><strong>思路</strong>：</p>
<ul>
<li>以”abcdefg”为例，想把它的前两个字符移到后面，得到”cdefgab”。</li>
<li>将前两个字符分到第一部分，将后面的所有字符分到第二部分。</li>
<li>先分别翻转这两部分，于是得到“bagfedc”。</li>
<li>接下来翻转整个字符串，得到“cdefgab”，刚好就是把原始字符串左旋转两位的结果。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.size()&lt;<span class="number">1</span> || n&gt;str.size() || n&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">int</span> startFirst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endFirst = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> startSecond = n;</span><br><span class="line">        <span class="keyword">int</span> endSecond = str.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 翻转字符串的前面n个字符</span></span><br><span class="line">        ReverseWord(str,startFirst,endFirst);</span><br><span class="line">        <span class="comment">// 翻转字符串的后面部分</span></span><br><span class="line">        ReverseWord(str,startSecond,endSecond);</span><br><span class="line">        <span class="comment">// 翻转整个字符串</span></span><br><span class="line">        ReverseWord(str,<span class="number">0</span>,str.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReverseWord</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = str[start];</span><br><span class="line">            str[start] = str[end];</span><br><span class="line">            str[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-把字符串转换成整数"><a href="#5-把字符串转换成整数" class="headerlink" title="5. 把字符串转换成整数"></a>5. 把字符串转换成整数</h2><p><strong>题目描述</strong><br>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br><strong>输入描述</strong>:<br>输入一个字符串,包括数字字母符号,可以为空<br><strong>输出描述</strong>:<br>如果是合法的数值表达则返回该数字，否则返回0<br><strong>示例</strong>:<br>输入:<br>+2147483647<br>    1a33<br>输出:<br>2147483647<br>    0<br><strong>思路</strong>：</p>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((cstr != <span class="literal">NULL</span>) &amp;&amp; (*cstr!= <span class="string">'\0'</span>)) <span class="comment">//字符串不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> minus = <span class="literal">false</span>; <span class="comment">//检查第一位是否为正负号</span></span><br><span class="line">            <span class="keyword">if</span>(*cstr==<span class="string">'+'</span>)</span><br><span class="line">                cstr++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*cstr==<span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cstr++;</span><br><span class="line">                minus = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(*cstr!=<span class="string">'\0'</span>)</span><br><span class="line">                num = StrToIntCore(cstr,minus);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* digit, <span class="keyword">bool</span> minus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(*digit!=<span class="string">'\0'</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//计算数字大小</span></span><br><span class="line">            <span class="keyword">if</span>(*digit&gt;=<span class="string">'\0'</span> &amp;&amp; *digit&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> flag = minus? <span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">                num = num*<span class="number">10</span>+flag*(*digit-<span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">//溢出判断</span></span><br><span class="line">                <span class="keyword">if</span>((!minus &amp;&amp; num&gt;<span class="number">0x7FFFFFFF</span>) || (minus &amp;&amp; num&lt;(<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    num=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">         		digit++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//非法输入</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="keyword">return</span> num;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-正则表达式匹配"><a href="#6-正则表达式匹配" class="headerlink" title="6. 正则表达式匹配"></a>6. 正则表达式匹配</h2><p><strong>题目描述</strong>:<br>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配<br><strong>思路</strong>：<br>A：下一个字符是<code>*</code><br>　　1.若当前字符匹配<br>　　　　选择1：匹配了，但我当作0匹配(匹配0次)。<code>s不动，p加2</code><br>　　　　选择2：匹配了，匹配结束(匹配1次)。<code>s+1,p+2</code><br>　　　　选择3：匹配了，我继续匹配下一个(匹配多次)。<code>s+1，p不动</code><br>　　2.当前字符不匹配。<code>s不动，p加2</code><br>B:下一个字符不是<code>*</code>，当前字符匹配。<code>s+1,p+1</code><br>C:下一个字符不是<code>*</code>，当前字符不匹配。<code>返回false</code><br>递归出口条件：<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(str==<span class="literal">NULL</span> || pattern==<span class="literal">NULL</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str,pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口条件:字符串和模式串同时走完</span></span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'\0'</span> &amp;&amp; *pattern==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归出口条件：字符串没走完，模式串走完，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(*str!=<span class="string">'\0'</span> &amp;&amp; *pattern==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//A：下一个字符是*</span></span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>)==<span class="string">'*'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1.若当前字符匹配</span></span><br><span class="line">            <span class="keyword">if</span>(*pattern==*str || (*pattern==<span class="string">'.'</span> &amp;&amp; *str!=<span class="string">'\0'</span>))</span><br><span class="line">            	<span class="keyword">return</span> matchCore(str,pattern+<span class="number">2</span>)    <span class="comment">//选择1：匹配了，但我当作0匹配(匹配0次)</span></span><br><span class="line">            		|| matchCore(str+<span class="number">1</span>,pattern+<span class="number">2</span>)  <span class="comment">//选择2：匹配了，匹配结束(匹配1次)    	</span></span><br><span class="line">            		|| matchCore(str+<span class="number">1</span>,pattern);    <span class="comment">//选择3：匹配了，我继续匹配下一个(匹配多次)</span></span><br><span class="line">            <span class="comment">//2.当前字符不匹配</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            	<span class="keyword">return</span> matchCore(str,pattern+<span class="number">2</span>); <span class="comment">//匹配结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B:下一个字符不是*，当前字符匹配</span></span><br><span class="line">        <span class="keyword">if</span>(*pattern==*str || (*pattern==<span class="string">'.'</span> &amp;&amp; *str!=<span class="string">'\0'</span>))</span><br><span class="line">             	<span class="keyword">return</span> matchCore(str+<span class="number">1</span>,pattern+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//C:下一个字符不是*，当前字符不匹配</span></span><br><span class="line">truetrue<span class="keyword">return</span> <span class="literal">false</span>;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-表示数值的字符串"><a href="#7-表示数值的字符串" class="headerlink" title="7. 表示数值的字符串"></a>7. 表示数值的字符串</h2><p><strong>题目描述</strong><br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br><strong>思路</strong>：</p>
<ul>
<li>表示数值的字符串: A<code>.</code>B<code>e/E</code>C 例如：“+123.45e+6”<ul>
<li>其中，A、C可能是以+/-开头的0~9的数位串，即整型；B也是0~9的数位串，但前面不能有正负号，即无符号整型。</li>
</ul>
</li>
<li>故步骤为：扫描A部分；遇到小数点<code>.</code>，扫描B部分；遇到<code>e/E</code>，扫描C部分。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> numeric = scanInteger(&amp;str);</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++str;</span><br><span class="line">            numeric = scanUnsignedInteger(&amp;str) || numeric;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'e'</span> || *str==<span class="string">'E'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++str;</span><br><span class="line">            numeric = numeric &amp;&amp; scanInteger(&amp;str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numeric &amp;&amp; *str==<span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="function"><span class="keyword">bool</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(**str==<span class="string">'+'</span> || **str==<span class="string">'-'</span>)</span><br><span class="line">            ++(*str);</span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* before = *str;</span><br><span class="line">        <span class="keyword">while</span>(**str!=<span class="string">'\0'</span> &amp;&amp; **str&gt;=<span class="string">'0'</span> &amp;&amp; **str&lt;=<span class="string">'9'</span>)</span><br><span class="line">            ++(*str);</span><br><span class="line">        <span class="keyword">return</span> *str&gt;before;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-字符串的排列"><a href="#8-字符串的排列" class="headerlink" title="8. 字符串的排列"></a>8. 字符串的排列</h2><p><strong>题目描述</strong><br>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br><strong>输入描述</strong>:<br>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。<br><strong>思路</strong>：</p>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h1><h2 id="1-构建乘积数组"><a href="#1-构建乘积数组" class="headerlink" title="1. 构建乘积数组"></a>1. 构建乘积数组</h2><p><strong>题目描述</strong><br>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。<br><strong>思路</strong>：</p>
<ul>
<li>把数组B看成一个矩阵来创建（见书中）。B[i]的值可以看作图中的矩阵中每行的乘积。</li>
<li>下三角用自上而下的顺序计算，<code>C[i] =C[i-1]*A[i-1]</code>。</li>
<li>上三角用自下而上的顺序计算，<code>D[i]= D[i+1]*A[i+1]</code>。</li>
<li>因此，先算下三角中的连乘，即先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) </span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">int</span> length = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(length); <span class="comment">//vector容器的构造函数</span></span><br><span class="line">        <span class="keyword">if</span>(length&lt;=<span class="number">0</span>) <span class="keyword">return</span> B;</span><br><span class="line">        <span class="comment">//计算下三角连乘</span></span><br><span class="line">        B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            B[i]=B[i<span class="number">-1</span>]*A[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算上三角</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=length<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            temp *= A[j+<span class="number">1</span>];</span><br><span class="line">            B[j] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-连续子数组的最大和"><a href="#2-连续子数组的最大和" class="headerlink" title="2. 连续子数组的最大和"></a>2. 连续子数组的最大和</h2><p><strong>题目</strong>：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。<br><strong>说明</strong>：例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为｛3, 10, -4, 7, 2}。因此输出为该子数组的和18。<br><strong>思路</strong>：</p>
<ul>
<li>从头到尾逐个累加数组中的每个数字。若加上<code>arr[i]</code>后的当前和<code>sumCurrent</code>小于<code>arr[i]</code>，则抛弃当前和<code>sumCurrent</code>及之前的所有数字，置当前和<code>sumCurrent</code>为<code>arr[i]</code>。同时每一步累加都记录下最大和<code>sumMax</code>。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="built_in">array</span>.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> sumCurrent=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumMax = <span class="number">0x80000000</span>;<span class="comment">//int的最小值</span></span><br><span class="line">        <span class="comment">//从头到尾逐个累加数组中的每个数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sumCurrent += <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="comment">//若当前和sumCurrent小于arr[i]</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]&gt;sumCurrent)</span><br><span class="line">                sumCurrent=<span class="built_in">array</span>[i];</span><br><span class="line">            <span class="comment">//记录下最大和sumMax</span></span><br><span class="line">            <span class="keyword">if</span>(sumCurrent&gt;sumMax) </span><br><span class="line">                sumMax = sumCurrent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-旋转数组的最小数字"><a href="#3-旋转数组的最小数字" class="headerlink" title="3. 旋转数组的最小数字"></a>3. 旋转数组的最小数字</h2><p><strong>题目描述</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序（递增，可能相等）的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><strong>思路</strong>：<br><strong>思路1</strong>：顺序查找，遍历数组，找到<code>arr[i]&gt;arr[i+1]</code>（稍微优化），时间复杂度$O(n)$，需改进。<br><strong>思路2</strong>：旋转数组是两个排序的子数组，采用二分查找。时间复杂度$O(logn)$：</p>
<ul>
<li><strong>情况1</strong>：<ul>
<li>用指针<code>p1</code>指向第一个数组的第一个元素，用指针<code>p2</code>指向第二个数组的第2个元素。对于旋转数组，有特性：<code>arr[p1]&gt;arr[p2]</code>（<code>第一个数组&gt;=第二个数组</code>）；</li>
<li>计算中间元素为指针<code>p</code>，如果<code>arr[p]&gt;=arr[p1]</code>，则指针<code>p</code>在第一个数组中，此时最小元素应该位于中间元素的后面，令<code>p1=p;</code>如果<code>arr[p]&lt;=arr[p1]</code>，则指针<code>p</code>在第二个数组中，此时最小元素应该位于中间元素的前面，令<code>p2 = p;</code>；</li>
<li><code>p1</code>始终在第一个数组，<code>p2</code>始终在第二个数组，故循环终止条件为：<code>(p1+1)=p2</code>，<code>arr[p2]</code>即为最小元素。</li>
</ul>
</li>
<li><strong>情况2</strong>：若旋转数组是将原来的0个元素搬到最后面，即数组有序，即<code>arr[p1]&lt;arr[p2]</code>，该情况是情况1中的特例，情况1中的做法是不适用的，直接返回最小元素<code>arr[0]</code>。</li>
<li><strong>情况3</strong>：当指针<code>p</code>，<code>p1</code>，<code>p2</code>指向的元素相同时，即<code>arr[p]==arr[p1] &amp;&amp; arr[p]==arr[p2]</code>时，无法判断该将中间的数字是位于第一个数组还是第二个数组，无法继续用二分法，转而对<code>[p1，p2]</code>采用顺序查找法。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路1：顺序查找，时间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!rotateArray.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = rotateArray.size();</span><br><span class="line">            <span class="comment">//顺序查找，遍历数组，找到arr[i+1]&lt;arr[i]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(rotateArray[i+<span class="number">1</span>]&lt;rotateArray[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    min = rotateArray[i+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路2：二分查找，时间复杂度O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.empty())  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = rotateArray.size();</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = size<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//情况2，数组有序，直接返回arr[0]</span></span><br><span class="line">        <span class="keyword">if</span>(rotateArray[p1]&lt;rotateArray[p2]) <span class="keyword">return</span> rotateArray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//情况1，二分查找</span></span><br><span class="line">        <span class="keyword">while</span>((p1+<span class="number">1</span>)!=p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = (p1+p2)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//情况3，转为对[p1,p2]采用顺序查找</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[p1]==rotateArray[p] &amp;&amp; rotateArray[p]==rotateArray[p2])</span><br><span class="line">                <span class="keyword">return</span> MinInOrder(rotateArray,p1,p2);</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[p]&gt;=rotateArray[p1]) p1 = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[p]&lt;=rotateArray[p2]) p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[p2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rotateArray,<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = p1;i&lt;p2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            	<span class="keyword">if</span>(rotateArray[i+<span class="number">1</span>]&lt;rotateArray[i])</span><br><span class="line">            	&#123;</span><br><span class="line">                	min = rotateArray[i+<span class="number">1</span>];</span><br><span class="line">                	<span class="keyword">break</span>;</span><br><span class="line">            	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-数字在排序数组中出现的次数"><a href="#4-数字在排序数组中出现的次数" class="headerlink" title="4. 数字在排序数组中出现的次数"></a>4. 数字在排序数组中出现的次数</h2><p><strong>题目描述</strong><br>统计一个数字在排序数组中出现的次数。<br><strong>思路</strong>：</p>
<ul>
<li><strong>思路1</strong>：顺序遍历数组，时间复杂度$O(n)$，需改进。</li>
<li><strong>思路2</strong>：有序数组，使用二分查找。分两次二分查找：<ul>
<li><strong>第一次</strong>找出该数字第一次出现的位置:<code>(mid==start) || (data[mid-1]!=target))</code>即已经是最左边的位置或其左边的一个数不等于该数；</li>
<li><strong>第二次</strong>找出该数字最后一次出现的位置：<code>(mid==end) || (data[mid+1]!=target)</code>即已经是最右边的位置或其右边的一个数不等于该数。</li>
</ul>
</li>
<li>可用递归实现，也可以用循环实现。</li>
</ul>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路2，递归实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">int</span> size = data.size();</span><br><span class="line">        <span class="keyword">int</span> firstIndex = getFirst(data,<span class="number">0</span>,size<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">int</span> lastIndex = getLast(data,<span class="number">0</span>,size<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">if</span> (firstIndex &gt; <span class="number">-1</span> &amp;&amp; lastIndex &gt; <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	number = lastIndex - firstIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]==target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((mid==start) || (data[mid<span class="number">-1</span>]!=target))<span class="comment">//让它是第一个出现的位置</span></span><br><span class="line">            <span class="comment">//if((mid==start) || (mid-1&gt;start&amp;&amp;data[mid-1]!=target))//等价</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> end = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;target) end = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getFirst(data,start,end,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]==target)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>((mid==end) || (data[mid+<span class="number">1</span>]!=target))<span class="comment">//让它是最后一个出现的位置</span></span><br><span class="line">           <span class="comment">//if((mid==end) || (mid+1&lt;end&amp;&amp;data[mid+1]!=target))//等价</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;target) end = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getLast(data,start,end,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-数组中重复的数字"><a href="#5-数组中重复的数字" class="headerlink" title="5. 数组中重复的数字"></a>5. 数组中重复的数字</h2><p>题目描述<br>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h2 id="6-数组中只出现一次的数字"><a href="#6-数组中只出现一次的数字" class="headerlink" title="6. 数组中只出现一次的数字"></a>6. 数组中只出现一次的数字</h2><p>题目描述<br>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h2 id="7-数组中出现次数超过一半的数字"><a href="#7-数组中出现次数超过一半的数字" class="headerlink" title="7. 数组中出现次数超过一半的数字"></a>7. 数组中出现次数超过一半的数字</h2><p>题目描述<br>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="8-把数组排成最小的数"><a href="#8-把数组排成最小的数" class="headerlink" title="8. 把数组排成最小的数"></a>8. 把数组排成最小的数</h2><p><strong>题目描述</strong><br>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><strong>思路</strong>：<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = numbers.size();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),compare);</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length;i++)</span><br><span class="line">            result += to_string(numbers[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> A = to_string(a)+to_string(b);</span><br><span class="line">        <span class="built_in">string</span> B = to_string(b)+to_string(a);</span><br><span class="line">        <span class="keyword">return</span> A&lt;B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="9-调整数组顺序使奇数位于偶数前面"><a href="#9-调整数组顺序使奇数位于偶数前面" class="headerlink" title="9. 调整数组顺序使奇数位于偶数前面"></a>9. 调整数组顺序使奇数位于偶数前面</h2><p><strong>题目描述</strong><br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><strong>思路</strong>：<br>1.剑指offer书中，是要求调整数组顺序，使得奇数位于偶数前面，没有要求奇数和奇数，偶数和偶数的相对位置不变。<br>解法是：指针<code>p1</code>指向数组头部，<code>p1</code>只后移。指针<code>p2</code>指向数组尾部，<code>p2</code>只前移。当<code>arr[p1]</code>为偶数，<code>arr[p2]</code>为奇数，则交换。<code>p1</code>继续后移，<code>p2</code>继续前移，一直循环。终止条件是：<code>p1</code>与<code>p2</code>交叉。<br>2.本题目中，要求奇数在前，偶数在后，且奇数相对于奇数，偶数相对于偶数的相对位置不变。则解法是：新建一个数组，先把原数组中的奇数push进去，再把偶数push进去，然后用新数组数据覆盖原数组即可。复杂度O(n)。<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="comment">//新建一个数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">//先把原数组中的奇数push进去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(<span class="built_in">array</span>[i]%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再把原数组中的偶数push进去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(<span class="built_in">array</span>[i]%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用新数组覆盖原数组</span></span><br><span class="line">        <span class="built_in">array</span>=result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="10-二维数组中的查找"><a href="#10-二维数组中的查找" class="headerlink" title="10. 二维数组中的查找"></a>10. 二维数组中的查找</h2><p><strong>题目描述</strong><br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>思路</strong>：首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则去除该数字所在列；如果该数字小于要查找的数字，则去除该数字所在行。<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">truetrue<span class="comment">//防御型编程</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//计算二维数组的行和列</span></span><br><span class="line">        <span class="keyword">int</span> rows = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> cols = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//首先选取数组中右上角的数字</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = cols<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;rows &amp;&amp; j&gt;=<span class="number">0</span>)<span class="comment">//注意二维数组行列的取值范围为[0~rows-1, 0~cols-1]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果该数字等于要查找的数字，则查找过程结束</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]== target)</span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果该数字大于要查找的数字，则去除该数字所在列</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]&gt;target)   </span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果该数字小于要查找的数字，则去除该数字所在行</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            	i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="11-数组中的逆序对"><a href="#11-数组中的逆序对" class="headerlink" title="11. 数组中的逆序对"></a>11. 数组中的逆序对</h2><p><strong>题目描述</strong><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br><strong>输入描述</strong>:<br>题目保证输入的数组中没有的相同的数字<br><strong>数据范围</strong>：<br>对于%50的数据,$size&lt;=10^4$<br>对于%75的数据,$size&lt;=10^5$<br>对于%100的数据,$size&lt;=2*10^5$<br><strong>示例</strong>:<br>输入<br>1,2,3,4,5,6,7,0<br>输出<br>7<br><strong>思路</strong>：</p>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不对，未完成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.size();</span><br><span class="line">        <span class="keyword">return</span> InversePairs2(data, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">truetrue<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//就是为了返回，返回的值无所谓</span></span><br><span class="line">        <span class="keyword">int</span> leftLength= n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> rightLength= n-leftLength;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;leftLength;i++) left.push_back(data[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = leftLength;i&lt;n;i++) right.push_back(data[i]);</span><br><span class="line">        InversePairs2(left,leftLength);    <span class="comment">//sorting the left subarray</span></span><br><span class="line">        InversePairs2(right,rightLength);  <span class="comment">//sorting the right subarray</span></span><br><span class="line">        mergeNew(data,left,leftLength,right,rightLength); <span class="comment">//merge left and right into A</span></span><br><span class="line">        <span class="keyword">return</span> count%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeNew</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; left, <span class="keyword">int</span> leftLength, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; right,<span class="keyword">int</span> rightLength)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=leftLength+rightLength<span class="number">-1</span>;</span><br><span class="line">truetrue<span class="keyword">int</span> j = leftLength<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = rightLength<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; k&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left[j]&gt;right[k]) </span><br><span class="line">            &#123; </span><br><span class="line">            	data[i--] = left[j--];</span><br><span class="line">            	count+=(k+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">            	data[i--] = right[k--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>) data[i--]=left[j--];</span><br><span class="line">        <span class="keyword">while</span>(k&gt;=<span class="number">0</span>) data[i--]=right[k--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="12-顺时针打印矩阵"><a href="#12-顺时针打印矩阵" class="headerlink" title="12. 顺时针打印矩阵"></a>12. 顺时针打印矩阵</h2><p><strong>题目描述</strong><br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   2  3  4</span><br><span class="line">5   6  7  8</span><br><span class="line">9  10 11 12</span><br><span class="line">13 14 15 16</span><br></pre></td></tr></table></figure></p>
<p>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<br><strong>思路</strong>：分解成若干个简单的问题。<br>1.每次打印矩阵的一个圈。关键：循环继续的条件是：<code>cols&gt;start*2 &amp;&amp; row&gt;start*2</code><br>2.将打印一圈分成四步：第一步，从左到右打印一行；第二步，从上到下打印一列；第三步；从右到左打印一行；第四步，从下到上打印一列。<br>3.四步的前提条件：<br>第一步总是需要；<br>第二步的前提条件是终止行号大于起始行号；<br>第三步的前提条件是该圈内至少两行两列，即终止行号大于起始行号，终止列号大于起始列号；<br>第四步的前提条件：该圈内至少有三行二列，即终止行号比起始行号至少大2，终止列号大于起始列号。<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">truetrue<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(rows&lt;=<span class="number">0</span> || cols&lt;=<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次打印矩阵的一个圈</span></span><br><span class="line">        <span class="keyword">while</span>(cols&gt;start*<span class="number">2</span> &amp;&amp; rows&gt; start*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintMatrixInCircle(matrix,rows,cols,start,result);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintMatrixInCircle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> start,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> endX = cols-start<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> endY = rows-start<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//1.从左到右打印矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;=endX;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(matrix[start][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.从上到下打印一列</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;endY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>;i&lt;=endY;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(matrix[i][endX]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.从右到左打印一行</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;endX &amp;&amp; start&lt; endY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = endX<span class="number">-1</span>;i&gt;=start;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(matrix[endY][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.从下到上打印一列</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;endX &amp;&amp; start &lt;endY <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = endY<span class="number">-1</span>; i&gt;=start+<span class="number">1</span>;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(matrix[i][start]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="六、排序"><a href="#六、排序" class="headerlink" title="六、排序"></a>六、排序</h1><h2 id="1-数组中出现次数超过一半的数字"><a href="#1-数组中出现次数超过一半的数字" class="headerlink" title="1.数组中出现次数超过一半的数字"></a>1.数组中出现次数超过一半的数字</h2><p>题目描述<br>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><strong>思路</strong>：结合数组特性：数组中有一个数字出现的次数超过了数组长度的一半，如果将这个数组排序，那么排序之后位于数组中间的数字一定就是那个出现次数超过数组长度一半的数字。这个数字就是统计学上的中位数，即长度为$n$的数组中第$n/2$大的数字。已经有成熟的时间复杂度为$O(n)$的算法得到数组中任意第$k$大的数字。<br>第一，防御性编程，判断数组是否有效；第二，利用快速排序中的分割(partition)方法，选主元位置及重排数组。如果返回的主元位置(pIndex)小于数组中间位置((length-1)/2)，则对左半部分进行分割，否则对右半部分进行分割，直到返回的pIndex等于((length-1)/2)；第三，遍历数组，验证该数是否出现了超过一半的次数。<br><!-- more --><br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> size = numbers.size();</span><br><span class="line">        <span class="comment">//1.防御性编程，判断数组是否有效；</span></span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = size<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = end/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//2.利用快速排序中的分割(partition)方法，选主元位置及重排数组</span></span><br><span class="line">        <span class="keyword">int</span> pIndex = partition(numbers,start,end);</span><br><span class="line">        <span class="comment">//直到返回的pIndex等于((length-1)/2)</span></span><br><span class="line">        <span class="keyword">while</span>(pIndex!=middle)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pIndex&lt;middle)</span><br><span class="line">            &#123;</span><br><span class="line">                start = pIndex+<span class="number">1</span>;</span><br><span class="line">                pIndex = partition(numbers,start,end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = pIndex<span class="number">-1</span>;</span><br><span class="line">                pIndex = partition(numbers,start,end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result=numbers[middle];</span><br><span class="line">        <span class="comment">//3.遍历数组，验证该数是否出现了超过一半的次数。</span></span><br><span class="line">        <span class="keyword">if</span>(isMoreThanHalf(numbers,result,size))</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = numbers[end];</span><br><span class="line">        <span class="keyword">int</span> pIndex = start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]&lt;=pivot)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">                numbers[i] = numbers[pIndex];</span><br><span class="line">                numbers[pIndex] = temp;</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = numbers[pIndex];</span><br><span class="line">        numbers[pIndex] = pivot;</span><br><span class="line">        numbers[end] = temp;</span><br><span class="line">        <span class="keyword">return</span> pIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMoreThanHalf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers,<span class="keyword">int</span> result,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==result)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*count&lt;=size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-最小的k个数"><a href="#2-最小的k个数" class="headerlink" title="2.最小的k个数"></a>2.最小的k个数</h2><p><strong>题目描述</strong>：<br>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。<br><strong>思路</strong>：<br>思路1：利用快速排序排序数组，位于前面的$k$个数即是最小的$k$个数。时间复杂度为$O(nlogn)$。<br>第一，防御性编程，如果数组为空或$k&gt;length$，则返回空；第二，利用快速排序，对数组进行排序；第三，输出数组中的前$k$个数。<br>思路2：<br>由上题“数组中出现次数超过一半的数字”得到启发，基于快速排序中的分割(partition)方法来解决问题。利用partiton函数，如果返回的$pIndex&lt;(k-1)$，则对右半部分进行partition，否则，对左半部分进行partition，直到返回的主元位置pIndex等于$(k-1)$。这样调整后，位于数组中左边的k个数字就是最小的$k$个数字，但这$k$个数字不一定是排序的。时间复杂度为$O(n)$。<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现思路1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> size = input.size();</span><br><span class="line">        <span class="comment">//1.防御性编程，如果数组为空或k&gt;size，则返回</span></span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span> || k&gt;size) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = size<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//2.利用快速排序，对数组进行排序</span></span><br><span class="line">        quickSort(input,start,end);</span><br><span class="line">        <span class="comment">//3.输出数组中的前k个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> pIndex = partition(numbers,start,end);</span><br><span class="line">        quickSort(numbers,start,pIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(numbers,pIndex+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = numbers[end];</span><br><span class="line">        <span class="keyword">int</span> pIndex = start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]&lt;=pivot)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">                numbers[i] = numbers[pIndex];</span><br><span class="line">                numbers[pIndex] = temp;</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = numbers[pIndex];</span><br><span class="line">        numbers[pIndex] = pivot;</span><br><span class="line">        numbers[end] = temp;</span><br><span class="line">        <span class="keyword">return</span> pIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="七、位运算"><a href="#七、位运算" class="headerlink" title="七、位运算"></a>七、位运算</h1><h2 id="1-数组中只出现一次的数字（-56）"><a href="#1-数组中只出现一次的数字（-56）" class="headerlink" title="1.数组中只出现一次的数字（#56）"></a>1.数组中只出现一次的数字（#56）</h2><p><strong>题目描述</strong><br>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br><strong>思路</strong>：核心思想：<a href="http://blog.csdn.net/ns_code/article/details/27568975" target="_blank" rel="noopener">异或去重</a>；异或的性质：交换律，结合律，以及<code>a^a=0</code>，<code>a^0=a</code><br><strong>1.考虑简单情况</strong>：数组中只有一个数字<code>n</code>出现了一次，其他都出现了两次。<br>将数组中所有元素逐个异或，则结果为只出现一次的<code>n</code>，即<code>a^a^b^b^...^n^...^c^c=n</code>。<br><strong>2.本题求解思路</strong>：故将数组分成两部分解决，一部分包含只出现一次的数字<code>n_1</code>，一部分包含只出现一次的数字<code>n_2</code>，同时保证出现两次的数字在同一数组,而不是分散在l不同的数组。对两数组分别逐元素异或，即分别得到<code>n_1</code>，<code>n_2</code>。<br><strong>3.数组划分方法</strong>：对整个数组，逐元素异或，则结果为<code>n_1^n_2</code>，即<code>n_1</code>和 <code>n_2</code>异或的结果。<code>n_1</code>和<code>n_2</code>不相同，故结果定不为0，则结果的二进制表示定至少有一位为1（即<code>n_1</code>和<code>n_2</code>的二进制表示的该位不相同），找出结果的二进制表示中第一次为1的下标索引<code>index</code>，通过这个下标索引<code>index</code>，对整个数组中的元素进行数组划分。数组中每个元素的二进制表示的第<code>index</code>位是1的分为一组，是0的分为另一组。这样保证了<code>n_1</code>和<code>n_2</code>分别在两个组，且出现两次的数字在同一个组，不会被分到不同的组(因此相同数字的二进制表示的<code>index</code>位必定是相同的)。<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">int</span> length = data.size();</span><br><span class="line">        <span class="keyword">if</span>(data.size()&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">//初始值为0,a^0=a</span></span><br><span class="line">        <span class="comment">// get num1 ^ num2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">            result ^=data[i];</span><br><span class="line">        <span class="comment">// get index of the first bit, which is 1 in resultExclusiveOR</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> indexOf1 = FindFirstBitIs1(result);</span><br><span class="line">        *num1 = *num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// divide the numbers in data into two groups,</span></span><br><span class="line">        <span class="comment">// the indexOf1 bit of numbers in the first group is 1,</span></span><br><span class="line">        <span class="comment">// while in the second group is 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(IsBit1(data[j],indexOf1))</span><br><span class="line">                *num1^=data[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2^=data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Find the index of first bit which is 1 in num (assuming not 0)</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">FindFirstBitIs1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> indexBit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(((num&amp;<span class="number">1</span>)==<span class="number">0</span>) &amp;&amp; (indexBit&lt;<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            num = num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            ++indexBit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexBit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Is the indexBit bit of num 1?</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBit1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> indexBit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num=num&gt;&gt;indexBit;</span><br><span class="line">        <span class="keyword">return</span> (num&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-二进制中1的个数"><a href="#2-二进制中1的个数" class="headerlink" title="2.二进制中1的个数"></a>2.二进制中1的个数</h2><p><strong>题目描述</strong><br>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br><strong>思路</strong>：<br><strong>首先</strong>，直观的思路是：先判断整数二进制表示中的最后一位是不是1；然后将整数右移一位，再次判断，直到整数变为0。判断二进制表示中最后一位是不是1的方法是：<code>n&amp;1</code>，因为1的二进制表示中除了最后一位为1以外，其余全为0。<br><strong>然后</strong>，右移整数n的做法存在隐患，就是当n是负数的时候，<a href="http://blog.csdn.net/morewindows/article/details/7354571" target="_blank" rel="noopener">n右移会在开头补符号位1（算术右移）</a>，而不是补0。故采用将1循环左移的方法，逐个判断n的二进制表示的第0位到最高位是否为1。<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">         <span class="comment">//直到1的循环左移为0</span></span><br><span class="line">         <span class="keyword">while</span>(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(n &amp; flag)</span><br><span class="line">             	count++;</span><br><span class="line">             <span class="comment">//左移1</span></span><br><span class="line">             flag =flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="八、递归"><a href="#八、递归" class="headerlink" title="八、递归"></a>八、递归</h1><h2 id="1-斐波那契数列（-10）"><a href="#1-斐波那契数列（-10）" class="headerlink" title="1.斐波那契数列（#10）"></a>1.斐波那契数列（#10）</h2><p><strong>题目描述</strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。(n&lt;=39)<br><strong>注</strong>：本题中<code>n=0</code>时，输出是0。斐波那契数列从第1项开始。即本题斐波那契数列是<code>0,1,1,2,3,5,...</code><br><strong>思路</strong>：<br><strong>思路1</strong>：最直观的递归，返回<code>Fibonacci(n-1)+Fibonacci(n-2)</code>。但有大量冗余计算，时间复杂度过高，无法通过。<br><strong>思路2</strong>：带记忆的递归，用辅助数组存储下已经计算过的结果。<br><strong>思路3</strong>：迭代计算。<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路1：最直观的递归，时间复杂度过高</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//思路2：带记忆的递归，用辅助数组存储下已经计算过的结果</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    int F[40];//默认为0</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(F[n]!= 0) </span><br><span class="line">            return F[n];</span><br><span class="line">        if(n&lt;=1) </span><br><span class="line">        &#123;</span><br><span class="line">         	F[n]=n;</span><br><span class="line">        	return F[n];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            F[n]=Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">        	return F[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//思路3：迭代计算。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">    	int num1=0;</span><br><span class="line">    	int num2=1;</span><br><span class="line">    	int num3;</span><br><span class="line">        if(n&lt;=1) </span><br><span class="line">            return n;</span><br><span class="line">truetruefor(int i = 2;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num3 = num1+num2;</span><br><span class="line">            num1 = num2;</span><br><span class="line">            num2 = num3;</span><br><span class="line">        &#125;</span><br><span class="line">        return num3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-青蛙跳台阶问题（-10）"><a href="#2-青蛙跳台阶问题（-10）" class="headerlink" title="2. 青蛙跳台阶问题（#10）"></a>2. 青蛙跳台阶问题（#10）</h2><p><strong>题目描述</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>思路</strong>：类似斐波那契数列<br>f(n)=　1, (n=1)<br>　　　 2, (n=2)<br>　　　 f(n-1)+f(n-2) ,(n&gt;2,n为整数)<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;=<span class="number">0</span>) <span class="keyword">return</span> number; <span class="comment">//defensive</span></span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(number<span class="number">-1</span>)+jumpFloor(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-变态跳台阶（-10）"><a href="#3-变态跳台阶（-10）" class="headerlink" title="3.变态跳台阶（#10）"></a>3.变态跳台阶（#10）</h2><p><strong>题目描述</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>思路</strong>：<br>因为n级台阶，第一步有n种跳法：跳1级，跳2级，…，跳n级<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)<br>所以f(n)=f(n-1)+f(n-2)+…+f(1)+f(0)<br>因为f(n-1)=f(n-2)+f(n-3)+…+f(1)+f(0)<br>所以f(n)=2xf(n-1)<br>故：<br>f(n)=　1, (n=1)<br>　　　 2xf(n-1),(n&gt;1,n为整数)<br><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;=<span class="number">0</span>) <span class="keyword">return</span> number; <span class="comment">//defensive</span></span><br><span class="line">truetrue<span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*jumpFloorII(number<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-矩形覆盖（-10）"><a href="#4-矩形覆盖（-10）" class="headerlink" title="4.矩形覆盖（#10）"></a>4.矩形覆盖（#10）</h2><p><strong>题目描述</strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2<em>n的大矩形，总共有多少种方法？<br><strong>思路</strong>：仍旧是斐波那契数列<br>第一块有两种方式：横着放和竖着放。<br>横着放后，覆盖方法为f(n-2)，因为下方也被占用，下方必须也横着放。<br>竖着放后，覆盖方法为f(n-1);<br>所以总的覆盖方法为f(n)=f(n-1)+f(n-2);<br>故：<br>f(n)=　1, (n=1)<br>　　　 2, (n=2)<br>　　　 f(n-1)+f(n-2) ,(n&gt;2,n为整数)<br><em>*代码</em></em>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(number&lt;=<span class="number">0</span>) <span class="keyword">return</span> number; <span class="comment">//defensive</span></span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> rectCover(number<span class="number">-1</span>)+rectCover(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="九、回溯"><a href="#九、回溯" class="headerlink" title="九、回溯"></a>九、回溯</h1><h1 id="十、动态规划与贪婪算法"><a href="#十、动态规划与贪婪算法" class="headerlink" title="十、动态规划与贪婪算法"></a>十、动态规划与贪婪算法</h1>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/29/排序算法/" rel="next" title="排序算法">
                <i class="fa fa-chevron-left"></i> 排序算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/02/基本概念/" rel="prev" title="基本概念">
                基本概念 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/me.jpg"
                alt="min" />
            
              <p class="site-author-name" itemprop="name">min</p>
              <p class="site-description motion-element" itemprop="description">防止遗忘</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="11172918@qq.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、链表"><span class="nav-text">一、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-两个链表的第一个公共结点"><span class="nav-text">1. 两个链表的第一个公共结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-链表中环的入口结点"><span class="nav-text">2. 链表中环的入口结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-反转链表"><span class="nav-text">3. 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-合并两个排序的链表"><span class="nav-text">4. 合并两个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-从尾到头打印链表"><span class="nav-text">5. 从尾到头打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-复杂链表的复制"><span class="nav-text">6. 复杂链表的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-链表中倒数第k个结点"><span class="nav-text">7. 链表中倒数第k个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-删除链表中的重复结点"><span class="nav-text">8. 删除链表中的重复结点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、栈和队列"><span class="nav-text">二、栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-用两个栈实现队列"><span class="nav-text">1. 用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-包含min函数的栈"><span class="nav-text">2. 包含min函数的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-栈的压入、弹出序列"><span class="nav-text">3. 栈的压入、弹出序列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、树"><span class="nav-text">三、树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-二叉树的深度"><span class="nav-text">1. 二叉树的深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-二叉树的镜像"><span class="nav-text">2. 二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-平衡二叉树"><span class="nav-text">3. 平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-把二叉树打印成多行"><span class="nav-text">4. 把二叉树打印成多行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-对称的二叉树"><span class="nav-text">5. 对称的二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-二叉树的下一个结点"><span class="nav-text">6. 二叉树的下一个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-二叉搜索树与双向链表"><span class="nav-text">7. 二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-从上往下打印二叉树"><span class="nav-text">8. 从上往下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-二叉树中和为某一值的路径"><span class="nav-text">9. 二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-按之字形顺序打印二叉树"><span class="nav-text">10. 按之字形顺序打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-二叉搜索树的第k个结点"><span class="nav-text">11. 二叉搜索树的第k个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-二叉搜索树的后序遍历序列"><span class="nav-text">12. 二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-树的子结构"><span class="nav-text">13. 树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-重建二叉树"><span class="nav-text">14. 重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-序列化二叉树"><span class="nav-text">15. 序列化二叉树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、字符串"><span class="nav-text">四、字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-替换空格"><span class="nav-text">1. 替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-整数中1出现的次数（从1到n整数中1出现的次数）"><span class="nav-text">2. 整数中1出现的次数（从1到n整数中1出现的次数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-翻转单词顺序列"><span class="nav-text">3. 翻转单词顺序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-左旋转字符串"><span class="nav-text">4. 左旋转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-把字符串转换成整数"><span class="nav-text">5. 把字符串转换成整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-正则表达式匹配"><span class="nav-text">6. 正则表达式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-表示数值的字符串"><span class="nav-text">7. 表示数值的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-字符串的排列"><span class="nav-text">8. 字符串的排列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、数组"><span class="nav-text">五、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-构建乘积数组"><span class="nav-text">1. 构建乘积数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-连续子数组的最大和"><span class="nav-text">2. 连续子数组的最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-旋转数组的最小数字"><span class="nav-text">3. 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-数字在排序数组中出现的次数"><span class="nav-text">4. 数字在排序数组中出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-数组中重复的数字"><span class="nav-text">5. 数组中重复的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-数组中只出现一次的数字"><span class="nav-text">6. 数组中只出现一次的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-数组中出现次数超过一半的数字"><span class="nav-text">7. 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-把数组排成最小的数"><span class="nav-text">8. 把数组排成最小的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-调整数组顺序使奇数位于偶数前面"><span class="nav-text">9. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-二维数组中的查找"><span class="nav-text">10. 二维数组中的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-数组中的逆序对"><span class="nav-text">11. 数组中的逆序对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-顺时针打印矩阵"><span class="nav-text">12. 顺时针打印矩阵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、排序"><span class="nav-text">六、排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-数组中出现次数超过一半的数字"><span class="nav-text">1.数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-最小的k个数"><span class="nav-text">2.最小的k个数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七、位运算"><span class="nav-text">七、位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-数组中只出现一次的数字（-56）"><span class="nav-text">1.数组中只出现一次的数字（#56）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-二进制中1的个数"><span class="nav-text">2.二进制中1的个数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八、递归"><span class="nav-text">八、递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-斐波那契数列（-10）"><span class="nav-text">1.斐波那契数列（#10）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-青蛙跳台阶问题（-10）"><span class="nav-text">2. 青蛙跳台阶问题（#10）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-变态跳台阶（-10）"><span class="nav-text">3.变态跳台阶（#10）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-矩形覆盖（-10）"><span class="nav-text">4.矩形覆盖（#10）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九、回溯"><span class="nav-text">九、回溯</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十、动态规划与贪婪算法"><span class="nav-text">十、动态规划与贪婪算法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">min</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
