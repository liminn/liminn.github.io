---
title: C/C++内存管理
date: 2017-11-26 21:33:00
categories: 
- C/C++
tags:
- C
- C++
- 内存管理
- 堆
- 栈
- 自由存储区
- malloc
- free
- new
- delete
- delete[]
---
## 1.内存分配方式
　　在C++中，内存分成5个区，它们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

 - 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
 - 堆：从技术上来说，堆是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用`malloc`时就会从中分配，稍后调用`free`可把内存交还。
 - 自由存储区：而自由存储是C++中通过`new`和`delete`动态分配和释放对象的抽象概念，通过`new`来申请的内存区域可称为自由存储区。
 - 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
 - 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
<!-- more --> 

## 2.malloc/free与new/delete的区别
`malloc`/`free`是C/C++语言的标准库函数，`new`/`delete`是C++的运算符。它们都可用于申请动态内存和释放内存。

 - 申请的内存所在位置：`new`操作符从自由存储区（free store）上为对象动态分配内存空间，而`malloc`函数从堆上动态分配内存。
 - `new`/`delete`会调用构造函数/析构函数对对象进行初始化与销毁，而`malloc`则不会 。对于非内部数据类型的对象而言，光用`maloc/free`无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于`malloc/free`是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于`malloc/free`。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符`new`，以及一个能完成清理与释放内存工作的运算符`delete`。注意`new/delete`不是库函数。
 - 操作符`new`/`delete`可以进行重载

 
## 3.delete与 delete []区别
 - `delete`只会调用一次析构函数，而`delete[]`会调用每一个成员的析构函数。在More Effective C++中：“当`delete`操作符用于数组时，它为每个数组元素调用析构函数，然后调用操作符`delete`来释放内存。”
 - 基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 `delete` 和 `delete[]`功能是相同的；但是对于类对象数组，只能用 `delete[]`；对于 `new` 的单个对象，只能用 `delete` 不能用 `delete[]` 回收空间。 
 - 总之，`delete`与`new`配套，`delete[]`与`new []`配套。

 
## 参考
1.[C++自由存储区是否等价于堆？](http://www.cnblogs.com/QG-whz/p/5060894.html)
2.[细说new与malloc的10点区别](http://www.cnblogs.com/QG-whz/p/5140930.html)
3.[C/C++内存管理详解，里面有错误](https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/)
4.[C++中delete和delete[]的区别](http://www.cnblogs.com/charley_yang/archive/2010/12/08/1899982.html)