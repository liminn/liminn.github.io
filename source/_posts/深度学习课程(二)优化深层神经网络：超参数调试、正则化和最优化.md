---
title: 深度学习课程(二)优化深层神经网络：超参数调试、正则化和最优化
mathjax: true
date: 2017-12-27 15:49:50
categories: 
- 深度学习
tags:
---
# **1.深度学习的实用层面**
## **1.1 建立机器学习应用**
### **训练/开发/测试集**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B1/%E8%AE%AD%E7%BB%83%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E9%9B%861.JPG" width="70%" height="70%">在实际中应用机器学习是一个高度迭代的过程：
- 在构建一个神经网络的时，需要设置许多超参数，例如神经网络的层数、每个隐藏层包含的神经元个数、学习速率、激活函数的选择等。实际上很难在第一次设置的时候就选择到这些最佳的参数，而是需要通过不断地迭代更新来获得。
- 迭代的过程如下：先有个想法，先选择初始的参数值，构建神经网络模型结构；然后通过代码实现；最后，通过实验验证。根据实验结果，对参数进行适当的调整优化，再进行下一次的Idea->Code->Experiment循环。
- 恰当的将数据分为训练/开发/测试集，可使得迭代效率更高。

<!-- more --> 

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B1/%E8%AE%AD%E7%BB%83%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E9%9B%862.JPG" width="90%" height="90%">一般地，将所有的样本数据分成三个部分：训练(Train)/开发(Dev)/测试(Test)集：
- 训练集用来训练你的模型；
- 开发集又称交叉验证集(cross validation set)，用来验证不同算法的表现情况，从中选择最好的模型；
- 测试集用来测试最好模型的实际表现，给出该模型的无偏估计。

关于数据集的比例划分，在以前，可获得的数据量不是很大的情况：
- 通常设置训练集和测试集的数量比例为70%和30%。如果有开发集，则设置比例为60%、20%、20%，分别对应训练/测试/开发集。
- 这种比例分配在样本数量不是很大的情况下，例如100,1000,10000，是比较科学的。
 
关于数据集的比例划分，在如今，大数据的时代：
- 如果数据量很大的时候，例如数据量达100万，70%/30%或60%/20%/20%的比例分配是不合理的。
- 因为开发集的目的是用来比较验证不同模型的优劣，从而选择更好的模型。因此，通常不需要所有样本的20%这么多的数据来进行验证。例如对于100万的样本，往往只需要10000个样本来做验证就够了。测试集的目的是给出已选定最优模型的无偏估计。对于100万的样本，往往也只需要10000个样本就够了。
- 科学的做法是要将开发集和测试集的比例设置得很低。因此，对于大数据样本，训练/开发/测试集的比例通常可以设置为98%/1%/1%，或者99%/0.5%/0.5%。样本数据量越大，相应的开发/测试集的比例可以设置的越低一些。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B1/%E8%AE%AD%E7%BB%83%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E9%9B%863.JPG" width="80%" height="80%">现代深度学习还有个重要的问题就是训练集和测试集的分布不匹配，意为是训练集和测试集来自于不同的分布。例如：
- 对于一个手机app，可以让用户上传图片，然后app识别出猫的图片。该应用中，训练集可能是从网络抓取的图片，而开发和测试集可能来自不同用户的上传的猫的照片。
- 从网络抓取的图片可能像素较高且拍摄专业等等，而用户上传的图片可能像素较低且模糊等等。因此，训练集和验证/测试集可能来自不同的分布。
- **解决方法：保证开发集和测试集来自于同一分布。**

注意：
- 如果不需要对最终选定的神经网络做出无偏估计，可以没有测试集，只有训练/开发集（也有人说成只有训练/测试集，都可以）。

### **偏差/方差**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B1/%E5%81%8F%E5%B7%AE%E5%92%8C%E6%96%B9%E5%B7%AE1.JPG" width="80%" height="80%"> 对于只有$x_1$和$x_2$两个特征的二维数据集，可以绘制数据，可视化偏差和方差。如上图所示：
- 左：高偏差，欠拟合
- 中：恰好
- 右：高方差，过拟合

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B1/%E5%81%8F%E5%B7%AE%E5%92%8C%E6%96%B9%E5%B7%AE2.JPG" width="80%" height="80%"> 对于高维数据，无法绘制数据以及可视化决策边界。但可通过几个指标来理解偏差和方差。
基于人工误差（或贝叶斯误差或最优误差)非常低（约为0%）并且训练集和开发集都来自于同一分布这两个假设，如上图所示：
- 训练集误差为1%/开发集误差11%，结合两者说明该算法在训练集上过拟合，导致在开发集上的泛化性能不好，推出高方差。
- 训练集误差为15%，在训练集上欠拟合，推出高偏差。开发集误差16%，相比于训练集误差只高1%，并不存在高方差。
- 训练集误差为15%，推出高偏差。开发集误差30%，相比于训练集误差高15%，推出高方差。
- 训练集误差为0.5%，低偏差。开发集误差1%，相比于训练集误差只高0.5%，低方差。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B1/%E5%81%8F%E5%B7%AE%E5%92%8C%E6%96%B9%E5%B7%AE3.JPG" width="70%" height="70%"> 上图展示了高偏差和高方差同时存在的可视化情形：
- 决策边界为线性，欠拟合，高偏差
- 在局部发生过拟合，高方差
- 该情形在二维情况下看起来不自然，但对于高维数据，这种情况是容易发生的。

### **机器学习的基本准则**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E5%87%86%E5%88%99.JPG" width="70%" height="70%"> 当训练好最初的神经网络时：
- 高偏差？通过训练集表现来确定，若存在高偏差，则可通过更大的网络或训练更长时间来解决。
- 高方差？通过开发集表现来确定，若存在高方差，则可通过获取更多数据及正则化来解决。
- 直到找到低偏差且低方差的网络。

关于偏差和方差的权衡：
- 在早期的机器学习时代，有很多关于偏差和方差的权衡的讨论，因为当时没有能够单独减小偏差和单独减小方差的工具。
- 而在如今的深度学习和大数据时代，通过扩大网络几乎总是能够较小偏差而不增大方差（只要用恰当的方式正则化）；通过获得更多数据几乎总是能够减小方差而不增大偏差。因此，这也解释了为何深度学习在监督学习中如此有效。

## **1.2 正则化神经网络**
### **正则化**
获得更多数据和正则化都是解决过拟合(高方差)的有效方法，但很多时候并不能总是获得更多数据或者获得更多数据的代价太高。
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B1/%E6%AD%A3%E5%88%99%E5%8C%96-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.JPG" width="80%" height="80%">先介绍在逻辑回归中应用正则化，如图：
- 逻辑回归：$J(w,b)=\frac1m\sum_{i=1}^mL(\hat y^{(i)},y^{(i)})$
- 参数：$w \in R^{n_x}$，$b\in R$
- 目的：$\min\limits_{w,b} J(w,b)$；
- $J(w,b)=\frac1m\sum_{i=1}^mL(\hat y^{(i)},y^{(i)})+\frac{\lambda}{2m}||w||_2^2$
 - L2正则化：`$||w||_2^2=\sum_{j=1}^{n_x}w_j^2=w^Tw$`，其中$\lambda$是正则化参数
- $J(w,b)=\frac1m\sum_{i=1}^mL(\hat y^{(i)},y^{(i)})+\frac{\lambda}{2m}||w||_1$
 - L1正则化：`$||w||_1=\sum_{j=1}^{n_x}|w_j|$`，其中$\lambda$是正则化参数
- 若使用L1正则化，$w$最后会变得稀疏，即$w$中会有很多0。有人认为这有助于压缩模型，因为有一部分参数是0，只需较少的内存来存储模型。
然而在实践中发现，通过L1正则化让模型变得稀疏带来的收效甚微。故吴恩达觉得至少在压缩模型的目标上，它的作用不大。
总之，在训练神经网络中，L2正则化应用地更频繁。
- 只正则化参数$w$，而省略正则化参数$b$的原因是：$w$是高维矢量参数，$b$只是一个标量，几乎所有的参数都集中在$w$中，$b$只是大量参数中的一个，故可省略。
- 注意，在python中，由于`lambda`是保留字，为了避免冲突，故在编程练习中使用`lambd`来表示$\lambda$。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%AD%A3%E5%88%99%E5%8C%96-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.JPG" width="50%" height="50%"> 在神经网络中应用正则化，如图：
- 代价函数：`$J(W^{[1]},b^{[1]},\cdots,W^{[L]},b^{[L]})=\frac1m\sum\limits_{i=1}^mL(\hat y^{(i)},y^{(i)})+\frac{\lambda}{2m}\sum\limits_{l=1}^L||W^{[l]}||_F^2$`
- 其中，矩阵的L2范数称为F范数(Frobenius范数)，`$||W^{[l]}||_F^2=\sum_{i=1}^{n^{[l]}}\sum_{j=1}^{n^{[l-1]}}(W_{ij}^{[l]})^2$`。
- 正则化后的梯度下降法：
 - $dW^{[l]}=dW^{[l]}_{before}+\frac{\lambda}{m}W^{[l]}$
 - $W^{[l]} =W^{[l]}-\alpha dW^{[l]}$

**L2正则化也被称作权重衰减(weight decay)**。原因如下：
- $$
\begin{eqnarray}W^{[l]} &:=&W^{[l]}-\alpha\cdot dW^{[l]}\\ &=&W^{[l]}-\alpha\cdot(dW^{[l]}_{before}+\frac{\lambda}{m}W^{[l]})\\ &=&(1-\alpha\frac{\lambda}{m})W^{[l]}-\alpha\cdot dW^{[l]}_{before} \end{eqnarray}
$$
- 其中，$(1-\alpha\frac{\lambda}{m})<1$。加上L2正则化项后，$W^{[l]}$的每次更新，都会乘以一个小于1的项。即每次迭代更新，都使得$W^{[l]}$不断地减小，故L2正则化又被称为权重衰减。

### **为什么正则化可以减轻过拟合**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%AD%A3%E5%88%99%E5%8C%96%E5%87%8F%E8%BD%BB%E8%BF%87%E6%8B%9F%E5%90%881.JPG" width="70%" height="70%">直观理解，如上图例一：
- 假设由于选择了非常复杂的神经网络模型，因而存在过拟合，如上图左上角所示。
- 加上正则化项后，若将正则化参数$\lambda$设置的很大，那么参数$ W^{[l]}\approx0$，参数$W$中的很多数接近于0，这相当于网络中的很多神经元不起作用，这样原本过于复杂的神经网络模型就变得简单化了，故减轻了过拟合。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%AD%A3%E5%88%99%E5%8C%96%E5%87%8F%E8%BD%BB%E8%BF%87%E6%8B%9F%E5%90%882.JPG" width="70%" height="70%">直观理解，如上图例二：
- 假设激活函数是`tanh`函数。`tanh`函数的特点是在$|z|$较小的区域，函数是近似线性的，而当$|z|$稍大的时候，才会展现出非线性能力。
- 若加入正则化，使$\lambda$较大，即对权重$W^{[l]}$的惩罚较大，使得$W^{[l]}$较小。
- 因为$z^{[l]}=W^{[l]}a^{[l]}+b^{[l]}$。当$W^{[l]}$较小，$z^{[l]}$也较小。当$z^{[l]}$在较小范围内时，激活函数$g(z)$就会近似于线性函数。因此每一层几乎都是线性的，当隐藏曾的激活函数是线性函数的时候，再多隐藏层也只是计算线性函数。故网络不能拟合复杂的非线性函数，便不容易过拟合了。

### **Dropout正则化**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/dropout-1.JPG" width="70%" height="70%"> 除了正则化外，还有另外一种防止过拟合的有效方法：Dropout(随机失活)：
- Dropout：在神经网络的训练过程中，每一次迭代，按照一定的概率随机地将其暂时从网络中丢弃。
- 也就是说，每一次迭代，每一层都有部分神经元不工作，起到简化复杂网络模型的效果，从而避免发生过拟合。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/dropout-2.JPG" width="50%" height="50%"> Dropout有不同的实现方法，Inverted dropout(反向失活)是目前最常用的实现方法：
- 假设对于第$l=3$层神经元，设定保留神经元比例概率`keep_prob=0.8`。在Python中，Inverted dropout可实现如下：
```Python
d3 = np.random.rand(a3.shape[0],a3.shape[1]) < keep_prob
a3 = np.multiply(a3,d3) #逐元素相乘，也可以写成 a3 *= d3
a3 /= keep_prob         #保持a3的期望值不变。这样在测试阶段也不用再对a3值进行缩放
```
 - 最后一步解释：例如`keep_prob=0.5`，该层将有一般的神经元被关闭，故该层的输出将被0.5缩放，因为只有剩下的一半神经元为计算输出做贡献。除以0.5等价于乘以2。因此输出有了相同的期望值。
- 反向传播过程：
```Python
da3 = np.multiply(da3,d3) #前向传播中关闭了某些神经元，反向传播中也关闭
da3 /= keep_prob          #a3缩放了keep_prob尺度，根据微积分的性质，则它的梯度也要缩放
```

注：Dropout仅在训练阶段使用，在测试阶段，不使用Dropout。
### **理解Dropout**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/dropout-3.JPG" width="50%" height="50%">如图，对于网络中的某一神经元，若采用了dropout，对于每个不同的样本，它的输入特征被消除的特征都不同，因此该神经元不能依靠任一输入特征，故最终网络会分散权重，即所有的权重都不会过大。
使用Dropout的时候的几个注意点：
- 可为不同网络层设置不同的`keep_prob`，但该做法的缺点是引入了更多的超参数。可将神经元较多(更容易过拟合)的隐藏层，`keep_out`设置得较小，如0.5；神经元越少的隐藏层，`keep_out`设置得较大，例如0.7。`keep_out`设置为1，表示全部保留，不使用Dropout。
- 不建议对输入层进行Dropout，如果输入层维度很大，例如图片，那么可以设置Dropout，但`keep_out`应设置的大一些，例如0.8，0.9。
- Dropout在计算机视觉领域中应用广泛（实际从AlextNet中提出），因为输入层(图像)维度较大，且通常没有足够多的训练样本。
- Dropout是一种正则化技巧，用来防止过拟合，只有在确认模型过拟合后，再使用它。
- Dropout的一大缺点是代价函数$J$不再被明确定义，每次迭代都会随机移除一些神经元。故失去了检查梯度下降这一项调式工具，即通过绘图检查代价函数$J$是否随着迭代次数而减小（定义明确的代价函数$J$，在每次迭代后都会下降）。故应关闭Dropout(`keep_out`设置为1)，再进行梯度下降检查。

### **其他正则化方法**
除了L2正则化和dropout之外，还有其它的正则化方法，如:数据增强，提前终止(early stopping)。
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%85%B6%E4%BB%96%E6%AD%A3%E5%88%99%E5%8C%96%E6%96%B9%E6%B3%951.JPG" width="60%" height="60%">数据增强是对已有的训练样本进行一些处理来“制造”出更多的样本。
- 例如图片识别问题中，数据增强是通过对已有的图片进行水平翻转、随机剪裁等方式制造出训练样本。
- 虽然这些新样本是基于原有样本的，可能新的训练集有些冗余，但是相对于重新搜集全新独立的数据，数据增强不需要成本。
- 因为增加了训练数据，能起到减轻过拟合的作用，故算过正则化方法。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%85%B6%E4%BB%96%E6%AD%A3%E5%88%99%E5%8C%96%E6%96%B9%E6%B3%952.JPG" width="80%" height="80%">另外一种正则化方法early stopping：如图，根据训练集误差曲线(或$J$的曲线)和开发集误差曲线(或$J$的曲线)随着迭代次数的变化趋势，选择使得开发集误差最小的迭代次数，停止训练，即early stopping。
- 直观解释：神经网络训练前,$W$的值趋近于0,随着训练的进行，$W$越来越大。early stopping相当于选取了一个不大不小的$W$，类似于$||w||_F$的效果，从而希望此时神经网络的过拟合不严重。

early stopping的缺点：
- 通常来说，机器学习训练模型有两个目标：一是优化代价函数，即减小$J$；二是防止过拟合。这两个任务是分开进行的。把这二者之间的关系称为正交化(orthogonalization)，后面课程会进一步讲解。
- early stopping的做法相当于将两个任务合在一起执行，减少迭代次数停止训练时，$J$就不会足够小，且希望此时不过拟合。

early stopping的优点：
- 相比与L2正则化，early stopping不用选择超参数$\lambda$。

吴恩达的做法：
- 偶尔用early stopping，一般只用L2正则化。

## 1.3 **设置优化问题**
### **归一化输入**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%A0%87%E5%87%86%E5%8C%96%E8%BE%93%E5%85%A51.JPG" width="80%" height="80%"> 在训练神经网络时，**归一化(normalize)输入**可以**加速训练过程($J$的优化过程)**。
归一化输入就是将原始数据减去其均值$\mu$后，再除以其方差$\sigma^2$：
- $\mu=\frac1m\sum_{i=1}^m x^{(i)}$
- $x = x-\mu$
- $\sigma^2=\frac1m\sum_{i=1}^m x^{(i)}**2$
- $x = x/ \sqrt{\sigma^2}$
- 注：对于训练集和测试集，应使用同样的$\mu$和$\sigma^2$进行归一化处理，即均使用训练集计算出的$\mu$和$\sigma^2$进行归一化处理。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%A0%87%E5%87%86%E5%8C%96%E8%BE%93%E5%85%A52.JPG" width="75%" height="75%"> 上图以二维输入特征为例，解释了为什么归一化输入可以加速训练过程：
- 假设输入特征为二维，且$x_1$的范围是[1,1000]，$x_2$的范围是[0,1]。  
- 如图左下所示，若不归一化输入，$x_1$与$x_2$之间分布极不平衡，代价函数$J$与$x_1$和$x_2$的等高线是一个细长的椭圆形。对其进行梯度下降算法时，容易发生振荡，且需选择很小的学习速率$\alpha$，来避免$J$发生振荡，一旦$\alpha$较大，必然发生振荡，故学习过程很慢。
- 如图右下所示，若归一化输入，$x_1$与$x_2$分布均匀，代价函数$J$与$x_1$和$x_2$的等高线是一个圆形。对其进行梯度下降算法时， 可选取较大的步长$\alpha$，且$J$不易发生振荡，故学习过程较快。
- 注意：如果输入特征的尺度非常不同，比如有些特征取值为[0,1]，有些是[1,1000]，那对输入进行归一化就很重要。而如果输入特征本来尺度就相近，那么这一步就不那么重要。
- 吴恩达的做法：因为归一化输入的步骤几乎从来没有任何害处，所以无论如何总是进行归一化，尽管不确定它是否会让训练变得更快。

### **梯度消失与梯度爆炸**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8.JPG" width="75%" height="75%"> 当训练深层神经网络时，会出现梯度消失和梯度爆炸问题。如图：
- 为便于分析，令各层的激活函数为线性函数，即$g(z)=z$，且令$b=0$。那么，该网络的预测输出$\hat y$为：
 - $\hat y=W^{[L]}W^{[L-1]}W^{[L-2]}\cdots W^{[3]}W^{[2]}W^{[1]}x $
- 如果各层权重$W^{[l]}$只比1或单位矩阵稍大一点（如1.5），深层神经网络的激活函数将作为层数$l$的函数指数级增长。
- 如果各层权重$W^{[l]}$只比1或单位矩阵稍小一点（如0.9），深层神经网络的激活函数将作为层数$l$的函数指数级递减。
- 虽然上图只论述了激活函数作为层数$l$的函数指数级增加或减少，同样可以论证表明，计算出的导数或梯度，也会指数级增加或指数级减少。
- 在一个非常深的神经网络（如150层）中，如果激活函数或梯度作为$l$的函数指数级的增大或减小，这些值会变得非常大或非常小，这会让训练变得非常困难。尤其是如果梯度作为$l$的函数指数级减小，梯度下降会用很小很小的步子走，梯度下降会用很长时间才能完成学习。

### **深层网络的权重初始化**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%B7%B1%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E6%9D%83%E9%87%8D%E5%88%9D%E5%A7%8B%E5%8C%96.JPG" width="80%" height="80%"> 针对梯度消失和梯度爆炸，有一种部分解决方法，虽然不能完全解决它，但帮助很大，即更小心地随机初始化神经网络。
如图，以初始化单个神经元为例，然后再把它应用到深层网络中：
- $z=w_1x_1+w_2x_2+...+w_nx_n$
- 为了让$z$不会过大或者过小，思路是让$w$与$n$有关，且$n$越大，$w$应该越小才好。这样能够保证$z$不会过大。
- 如果激活函数是`tanh`，一般在初始化$w$时，令其方差为$\frac1n$，即$Var(w)=\frac1n$：
 - 公式表示为：$w^{[l]} = np.random.randn(n^{[l]},n^{[l-1]})*np.sqrt(\frac{1}{n^{[l-1]}})$
 - 解释：第$l$层中的每个神经元都有$n^{[l-1]}$个输入。标准正态分布均值为0，方差为1，乘以$np.sqrt(\frac{1}{n^{[l-1]}})$，那么$w$的方差便为$\frac{1}{n^{[l-1]}}$
 方差性质：$C$为常数，$D(CX) = C^2D(X)$
 - 该初始化方法也称为“Xavier initialization”。
- 如果激活函数是`ReLU`，一般在初始化$w$时，令其方差为$\frac2n$，即$Var(w)=\frac2n$：
 - 公式表示为：$w^{[l]} = np.random.randn(n^{[l]},n^{[l-1]})*np.sqrt(\frac{2}{n^{[l-1]}})$
 - 该初始化方法也称为“He initialization”。
- 除此之外，Yoshua Bengio提出了另外一种初始化$w$的方法，令其方差为$\frac{2}{n^{[l-1]}+n^{[l]}}$：
 - 公式表示为：$w^{[l]} = np.random.randn(n^{[l]},n^{[l-1]})*np.sqrt(\frac{2}{n^{[l-1]}+n^{[l]}})$
- 注：视频中3：15秒处，还有一段关于解释该做法可以有效减缓梯度消失/梯度爆炸的原因，没听懂，待理解。

### **梯度的数值逼近**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%A2%AF%E5%BA%A6%E7%9A%84%E6%95%B0%E5%80%BC%E9%80%BC%E8%BF%91.JPG" width="80%" height="80%"> 对于神经网络的反向传播，有一项重要的测试——梯度检验(gradient checking)。该节先介绍梯度的数值逼近：
- 采用双边差分公式进行数值逼近：$f'(\theta) \approx \frac{f(\theta+\varepsilon)-f(\theta-\varepsilon)}{2\varepsilon}$
- 如$f(\theta)=theta^3$，当$\theta$为1，$\varepsilon$为0.01时，逼近误差为：0.0001
- 注意：不采用单边差分公式：$f'(\theta) \approx \frac{f(\theta+\varepsilon)-f(\theta)}{\varepsilon}$进行梯度的数值逼近的原因是：
 - 单边差分公式的逼近误差是$O(\varepsilon)$。
 - 双边差分公式的逼近误差是$O(\varepsilon^2)$，逼近误差更小，故本课程采用此方法。
- 即利用的是该导数定义：$$ f'(\theta) = \lim\limits_{\varepsilon \to 0} \frac{f(\theta + \varepsilon) - f(\theta - \varepsilon)}{2 \varepsilon} $$，而不是该导数定义：$$f'(\theta) = \lim\limits_{\varepsilon \to 0} \frac{f(\theta + \varepsilon) - f(\theta)}{\varepsilon}$$

### **梯度检验**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%A2%AF%E5%BA%A6%E6%A3%80%E9%AA%8C1.JPG" width="75%" height="75%"> <img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%A2%AF%E5%BA%A6%E6%A3%80%E9%AA%8C2.JPG" width="75%" height="75%"> 进行梯度检验，可验证代码中的反向传播是否有错误：
- 首先，将$W^{[1]},b^{[1]},\cdots,W^{[L]},b^{[L]}$ 这些矩阵逐个转变为一维向量，然后连接成一个大的一维向量$\theta$。这样$J(W^{[1]},b^{[1]},\cdots,W^{[L]},b^{[L]})$ 就可表示成$J(\theta)$。
- 然后，将反向传播过程通过梯度下降算法得到的$dW^{[1]},db^{[1]},\cdots,dW^{[L]},db^{[L]}$同上一步骤一样构造成一个大的一维向量 $d\theta$。注意到，$d\theta$的维度与$\theta$是一致的。
- 接着，对$\theta$中的每个元素$\theta_i$，计算近似梯度：
$$d\theta_{approx}[i]=\frac{J(\theta_1,\theta_2,\cdots,\theta_i+\varepsilon,\cdots)-J(\theta_1,\theta_2,\cdots,\theta_i-\varepsilon,\cdots)}{2\varepsilon}$$
- 最终，得到$d\theta_{approx}$。
- 将`$d\theta_{approx}$`与`$d\theta$`相比较，检查是否一致，即是否`$d\theta_{approx} \approx d\theta $`，也即是否每一元素`$d\theta_{approx}[i] \approx d\theta[i] $`。
- 检验相似度的标准如下：
$$\frac{||d\theta_{approx}-d\theta||_2}{||d\theta_{approx}||_2+||d\theta||_2}$$
 - 解释：首先计算`$d\theta_{approx}$`与`$d\theta$`的欧氏距离，即差值的L2范数。然后根据向量的长度将其归一化，即除以两个向量的欧几里德长度和，除以该分母的原因是：防止分子过大或过小，这样整个式子就成了一个比值。
 - 在实际中，选用$\varepsilon=10^{-7}$：
 - 如果相似度的值小于$10^{-7}$，表明梯度逼近误差极小，通过梯度检查，代码是对的。
 - 如果相似度在$10^{-5}$左右，代码可能是对的，但还是会逐个检查向量`$d\theta_{approx}$`与`$d\theta$`的每一项，看是否有某一项过大。则该处代码可能存在错误，下节会稍详细讲解此点。
 - 如果相似度在$10^{-3}$左右，代码中一定有错误。

### **运用梯度检验的注意事项**
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%A2%AF%E5%BA%A6%E6%A3%80%E9%AA%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.JPG" width="75%" height="75%"> 在运用梯度检查时有几点注意事项：

- 一旦确定反向传播正确，即关闭梯度检验，否则训练过程会极慢。
 - 解释：梯度检验很慢,故不在训练的每一次迭代中都使用。只要确定反向传播代码正确, 就关闭它。
- 如果梯度检验出现错误，找到对应出错项，尝试识别出bug位置：
 - 解释：逐个对比向量`$d\theta_{approx}$`与`$d\theta$`的每一项，看是否有某一项`$d\theta[i]$`过大。例如，过大项`$d\theta[i]$`属于$dw^{[l]}$，而同一层的$db^{[l]}$未出错，则可能bug在关于$dw^{[l]}$的代码中。
 - 有时这样的分析虽然无法帮助精确定位出bug位置，但可以帮助我们猜测bug的位置。
- 如果进行了正则化，则计算近似梯度$d\theta_{approx}$的时候要包括进去。
- 梯度检验时关闭dropout，梯度检验完毕后再打开dropout。
 - 解释：dropout使得$J$没有精确的定义，无法进行$d\theta_{approx}$的计算。故先梯度检验，通过后，再开启dropout。
- 随机初始化时运行梯度检验，经过一些训练后再次进行梯度检验（不常用）。
 - 为了预防你的反向传播算法在$w$和$b$在接近0的时候是正确的，但当$w$和$b$变大时，算法精度有所下降。
 - 故在一些迭代后，当$w$和$b$变大时，再次进行梯度检验。

# 2.优化算法
## 2.1 优化算法
### 小批量梯度下降法
开篇即说过，机器学习应用是一个高度依赖经验的需要大量迭代的过程。优化算法可以加快神经网络的训练速度，从而提高效率。
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%951.JPG" width="80%" height="80%"> 批量梯度下降法(batch gradient descent)：
- 每次迭代，对所有样本进行训练，故其训练速度很慢。

小批量梯度下降法(mini-batch gradient descent)：
- 将$m$个训练样本分成若干个子集，称为mini-batch。
- 然后每次迭代，在单一子集(mini-batch)上进行神经网络训练，每次迭代所需时间大幅减少。

如图中示例：
- 总的训练样本$X_{(n_x,m)}=[x^{{1}},x^{(2)},...,x^{(m)}]$，其中$m=5,000,000$。
- 总的训练样本的标签$Y_{(1,m)}=[y^{{1}},y^{(2)},...,y^{(m)}]$，其中$m=5,000,000$。
- 将$X$分成5000个mini-batch，每mini-batch含1000个样本，将每个mini-batch记为`$X^{\{t\}}$` ，其维度为`$(n_x,1000)$`,且`$t=1,2,\cdots,5000$`。
- 每个mini-batch对应的标签记为`$Y^{\{t\}}$`，其维度为`$(1,1000)$`，且`$t=1,2,\cdots,5000$`。

总结一下遇到的神经网络中几类字母的上标含义：
- $x^{(i)}$ ：第$i$个样本
- $z^{[l]}$ ：神经网络第$l$层网络的线性输出
- `$X^{\{t\}},Y^{\{t\}}$`：第$t$个mini-batch

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D2.JPG" width="80%" height="80%"> 如图：
- 对于小批量梯度下降法来说，一个周期(epoch)是指：将所有mini_batch（`$X^{\{t\}},Y^{\{t\}}$`）训练一次(前向传播、计算$J$、反向传播、参数更新)，即遍历一次总体训练集。
- 对于批量梯度下降法，一个周期只进行一次梯度下降步骤；而对于小批量梯度下降法，一个周期会进行$T$次梯度下降步骤。
- 通常，会多次遍历训练集(一个显式的for循环)直到收敛到某个值。

### 理解小批量梯度下降法
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E7%90%86%E8%A7%A3%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D1.JPG" width="80%" height="80%">
- 使用批量梯度下降法，每次迭代将遍历整个训练集，$J$都会减小，若没有减小，则一定是某处错了。
- 使用小批量梯度下降法，每次迭代是在不同的mini-batch上训练，其代价函数$J$和迭代次数(也即mini-batch/t)的曲线存在噪声，上下振荡，但整体的趋势是下降的。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E7%90%86%E8%A7%A3%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D2.JPG" width="80%" height="80%"> 对于mini-batch尺寸的选择：
- 如果mini-batch尺寸为m：即为批量梯度下降((Batch) Gradient Descent)。`$X^{\{t\}},Y^{\{t\}}=(X,Y)$`
- 如果mini-batch尺寸为1：即为随机梯度下降(Stochastic Gradient Descent, SGD)。每个样本都是一个mini-batch。
- 实际操作中：mini-batch尺寸的选择在1到m之间。

如图，比较各梯度下降方法的代价函数的等高线图：
- 蓝色曲线代表批量梯度下降：
 - 它的噪声相对较小。
 - 每一步相对较大。
 - 并且最终可以达到最小值。
 - 缺点：每次迭代所需时间太长。
- 紫色曲线代表随机梯度下降：
 - 对于每一次迭代，就在一个样本上做梯度下降，噪声非常大。
 - 一般来说它会沿着正确的方向，但有时也会指向错误的方向。
 - 最后也不会收敛到一个点，它一般会在最低点附近摆动，但是不会达到并且停在那里。 
 - 缺点：失去了通过向量化来加速计算这个工具。
- 绿色曲线代表实际中mini-batch尺寸为1~m之间的梯度下降：
 - 优点：有着最快的学习速度：1.可在每一个mini-batch运用向量化。2.每次迭代所需时间少。
  
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E7%90%86%E8%A7%A3%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D3.JPG" width="75%" height="75%">
- 如果总体样本数量$m$($m\leq2000$)，建议直接使用批量梯度下降。
- 如果总体样本数量$m$很大时，建议将样本分成许多mini-batch。
- 推荐常用的mini-batch 尺寸为64,128,256,512(这些都是2的幂。之所以这样设置的原因是计算机存储数据一般是2的幂，这样设置可以提高运算速度)。
- 但要确保每一个mini-batch（`$X^{\{t\}},Y^{\{t\}}$`）能装进CPU/GPU。
- 在实践中，要得到不同的mini-batches，需要两个步骤：1.对数据集洗牌(shuffle)；2.分割(partition)。

### 指数加权平均
接下来介绍几个优化算法，它们比梯度下降更快，为了理解这些算法，需要用到一种叫指数加权平均(exponentially weighted average)的操作，在统计学上也被称为指数加权滑动平均。
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%871.JPG" width="80%" height="80%"> 如图，通过指数加权平均来计算最近10天的温度：
- 设$V_0=0$，当成第0天的气温值
- 第一天的气温与第0天的气温有关：$V_1=0.9V_0+0.1\theta_1$
- 第二天的气温与第一天的气温有关：$V_2=0.9V_1+0.1\theta_2$
- 第$t$天与第$t-1$天的气温迭代关系为：`$V_t = 0.9V_{t-1}+0.1\theta_t$`
- 经过指数加权平均得到的气温如图中红色曲线所示。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%872.JPG" width="80%" height="80%"> 指数加权平均的一般形式为：
- `$V_t=\beta V_{t-1}+(1-\beta)\theta_t$`
- `$V_t$`是在约`$\frac{1}{1-\beta}$`天的温度上的平均的近似值。
- 当$\beta=0.5$，则$\frac{1}{1-\beta}=2$，表示将前2天进行指数加权平均。由于仅仅平均两天的气温，即只在很小的窗口内计算平均。得到结果中会有更多的噪声，更容易受到异常值的影响，但它可以更快地适应温度变化。如图中黄色曲线所示。
- 当$\beta=0.9$，则$\frac{1}{1-\beta}=10$，表示将前10天进行指数加权平均。如图中红色曲线所示。
- 当$\beta=0.98$，则$\frac{1}{1-\beta}=50$，表示将前50天进行指数加权平均。如图中绿色曲线所示。
- $\beta$值越大，则指数加权平均的天数越多，平均后的曲线则更平滑，但是同时曲线会右移，因为在一个更大的窗口内计算平均温度，在温度变化时，适应地更加缓慢，这就造成了一些延迟。
- 可将$\beta$视为一个超参数，通过调整这个参数，就可以得到略微不同的收效。通常取中间的某个值效果最好，也就是这里的红色的曲线。

### 理解指数加权平均
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E7%90%86%E8%A7%A3%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%871.JPG" width="80%" height="80%"> 上图解释了为什么指数加权平均的结果`$V_t$`是在约`$\frac{1}{1-\beta}$`天的温度上的平均的近似值：
- 准确来说，指数加权平均算法跟之前所有天的数值都有关系，如图中的推导公式:
 - $$\begin{eqnarray}V_{100} &=& 0.1\theta_{100}+ 0.1\cdot0.9\theta_{99}+  0.1\cdot0.9^{2}\theta_{98}+ 0.1\cdot0.9^{3}\theta_{97} + 0.1\cdot0.9^{4}\theta_{96}+ ... \end{eqnarray}$$
- 其中每一$\theta_{i}$项都是指数衰减的，一般认为衰减到原始的$\frac1e$就可以忽略不计了。
- $\beta^{\frac{1}{1-\beta}}=\frac1e$，例如，此处$\beta=0.9$，$0.9^{10}\approx 0.35\approx \frac{1}{e}$。
- 故`$V_t$`是在约`$\frac{1}{1-\beta}$`天的温度上的平均的近似值。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E7%90%86%E8%A7%A3%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%872.JPG" width="80%" height="80%">  实际应用中，使用这样的语句来实现指数加权平均算法：
`$V_{\theta}=0$`
`$Repeat\ \{$`
`$\ \ \ \ Get\ next\ \theta_t$`
`$\ \ \ \ V_{\theta}:=\beta V_{\theta}+(1-\beta)\theta_t$`
`$\}$`

### 指数加权平均中的偏差修正
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E7%9A%84%E5%81%8F%E5%B7%AE%E4%BF%AE%E6%AD%A3.JPG" width="80%" height="80%">
- 上文中提到当$\beta=0.98$时，指数加权平均结果如下图绿色曲线所示。但是实际上，得不到绿色曲线，真实曲线如紫色曲线所示。
- 紫色曲线与绿色曲线的区别是：紫色曲线开始的时候相对较低一些。这是因为设置$V_0=0$，所以初始值会相对小一些，直到后面受前面的影响渐渐变小，趋于正常:
 - $V_0=0$
 - $V_1 = 0.98V_0+0.02\theta_1$
 - $V_2 = 0.98V_1+0.02\theta_2=0.98 \cdot 0.02\theta_1+0.02\theta_2=0.0196\theta_1+0.02\theta_2$
 
修正这种问题的方法是进行偏移修正(bias correction):
- 将$V_t$取值变为$\frac{V_t}{1-\beta^t}$
- 在刚开始的时候，$t$比较小，$(1-\beta^t)<1$，这样就将$V_t$修正得更大一些，效果是把紫色曲线开始部分向上提升一些，与绿色曲线接近重合。
- 随着$t$增大，$(1-\beta^t)\approx1$，$V_t$基本不变，紫色曲线与绿色曲线依然重合。
- 这样就实现了简单的偏移校正，得到我们希望的绿色曲线。
- 在机器学习中，多数的指数加权平均运算并不会使用偏差修正。因为大多数人更愿意在初始阶段，用一个稍带偏差的值进行运算。
- 不过，如果在初始阶段就开始考虑偏差，指数加权移动均指仍处于预热阶段，偏差修正可以帮你尽早做出更好的估计。

### 动量梯度下降法
有一种算法叫做动量(Momentum)梯度下降算法，它几乎总会比标准的梯度下降算法更快。算法的主要思想是：计算梯度的指数加权平均，然后使用这个梯度来更新权重。
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%8A%A8%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D1.JPG" width="80%" height="80%"> <img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%8A%A8%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D2.JPG" width="80%" height="80%">
- 假设要优化一个代价函数，如图中的等高线图,红色的点表示最小值的位置。
- 无论是批量梯度下降或小批量梯度下降，梯度下降算法会向着最小值缓慢地振荡前进。这种上下的振荡会减慢梯度下降的速度，同时也让你无法使用较大的学习率。如果你使用的学习率很大，可能会超调(overshoot)，发散出去。因此为了避免振荡过大，你只能使用比较小的学习率。如图1中的蓝色曲线所示。
- 因此，在垂直方向上，希望学习慢一点，因为你不希望有这些振荡；但是在水平方向上，你希望加快学习速度。 

动量梯度下降算法的过程如下:
`$V_{dW}=0,V_{db}=0$`
`$On\ iteration\$`
`$\ \ \ \ Compute\ dW,\ db\ on\ the\ current\ mini-batch$`
`$\ \ \ \ V_{dW}=\beta V_{dW}+(1-\beta)dW$`
`$\ \ \ \ V_{db}=\beta V_{db}+(1-\beta)db$`
`$\ \ \ \ W=W-\alpha V_{dW},\ b=b-\alpha V_{db}$`

- 使用`$v_{dW}$`更新权重，而不是`$dW$`。同样地用`$v_{db}$`更新`$b$`，而不是`$db$`。
- $v_{dW}$是在近10个$dW$上的指数加权平均，故**在垂直方向上，其平均值接近于0**。然而**在水平方向上，所有导数都指向水平方向的右边，所以水平方向的平均值仍然较大**。
- 因此，**动量梯度下降算法的每一步，在垂直方向上的振荡非常小，且在水平方向上运动得更快**。这会让你的算法选择更加直接的路径，或者说减弱了前往最小值的路径上的振荡，如图1中红色曲线所示。 

另外：
- 使用动量梯度下降法有两个超参数：$\alpha$和$\beta$。$\beta$最常用的取值是0.9，就像之前计算最近10天气温的平均值，这里就是计算前10次迭代的梯度的平均值。在实践中，使用$\beta=0.9$效果很好，你也可以尝试不同的值，做一些超参数搜索，但是0.9是非常稳健的参数值。
- 至于偏差修正，即是否需要让`$v_{dW}$`或`$v_{db}$`除以`$1-\beta^t$`。实际上，通常人们不会这么做，因为在10次迭代之后，滑动平均值就不再是一个偏差估计，所以在实现梯度下降或动量梯度下降时，不用做偏差修正。

### RMSprop
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/RMSprop.JPG" width="80%" height="80%"> RMSprop的算法的全称为均方根传递(Root Mean Square prop)，它同动量梯度下降法一样，也可以加速梯度下降：
- 批量梯度下降或小批量梯度下降在实现梯度下降时，可能会在垂直方向上出现巨大的振荡，即使它试图在水平方向上前进。
- 假设垂直方向代表参数$b$，水平方向代表参数$W$，当然这里也可以是$W_1$和$W_2$等其他参数，使用$b$和$W$是为了便于标记解释。 
- 你希望减慢$b$方向的学习，也就是垂直方向，同时加速或至少不减慢水平方向的学习，这就是RMSprop算法要做的。
- RMSprop算法步骤：
`$S_{dW},\ S_{db}=0$`
`$On\ iteration\ t:$`
`$\ \ \ \ Compute\ dW,\ db \ on \ current \ mini-batch$`
`$S_{dw}=\beta S_{dW}+(1-\beta)dW^2$`
`$S_{db}=\beta S_{db}+(1-\beta)db^2$`
`$W:=W-\alpha \frac{dW}{\sqrt{S_{dw}+\varepsilon}},\ b:=b-\alpha \frac{db}{\sqrt{S_{db}+\varepsilon}}$`
 - 其中，$dW^2$和$db^2$是逐元素平方。
 - 其中，$\varepsilon=10^{-8}$。为了防止除以0。$\epsilon$的值取多少并不重要，$10^{-8}$是一个合理的默认值，能轻微提高数值稳定性。
- 从图中蓝色曲线可以看出，$db$很大，而$dW$相对较小，因此，`$S_{dW}$`相对`$S_{db}$`较小。
- 因此RMSprop中垂直方向的$b$的更新较小，这有助于减弱振荡，垂直方向$W$的更新较大。另一个收效是：可以使用更大的学习率$\alpha$，学习得更快，而不用担心在垂直方向上发散。如图中绿色曲线所示。

### Adam优化算法
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/Adam1.JPG" width="90%" height="90%"> Adam算法（Adaptive Moment Estimation，自适应矩估计)将动量和RMSprop梯度下降结合起来，被广泛使用且已经被证明在很多不同种类的神经网络构架中都是十分有效的。
- Adam算法流程为： 
`$V_{dW}=0,\ S_{dW},\ V_{db}=0,\ S_{db}=0$`
`$On\ iteration\ t:$`
`$\ \ \ \ Cpmpute\ dW,\ db \ on \ current \ mini-batch$`
`$\ \ \ \ V_{dW}=\beta_1V_{dW}+(1-\beta_1)dW,\ V_{db}=\beta_1V_{db}+(1-\beta_1)db$`
`$\ \ \ \ S_{dW}=\beta_2S_{dW}+(1-\beta_2)dW^2,\ S_{db}=\beta_2S_{db}+(1-\beta_2)db^2$`
`$\ \ \ \ V_{dW}^{corrected}=\frac{V_{dW}}{1-\beta_1^t},\ V_{db}^{corrected}=\frac{V_{db}}{1-\beta_1^t}$`
`$\ \ \ \ S_{dW}^{corrected}=\frac{S_{dW}}{1-\beta_2^t},\ S_{db}^{corrected}=\frac{S_{db}}{1-\beta_2^t}$`
`$\ \ \ \ W:=W-\alpha\frac{V_{dW}^{corrected}}{\sqrt{S_{dW}^{corrected}}+\varepsilon},\ b:=b-\alpha\frac{V_{db}^{corrected}}{\sqrt{S_{db}^{corrected}}+\varepsilon}$`
 - 注意到：在构建Adam算法的过程中需要进行偏差修正。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/Adam2.JPG" width="80%" height="80%">
- Adam算法中的超参数：$\alpha$，$\beta_1$，$\beta_2$，$\varepsilon$。
- 超参数$\beta_1$的默认值设置为0.9，这是关于动量算法的$dW$的加权平均计算。
- 对于超参数$\beta_2$，Adam算法论文的作者推荐使用0.999，这是关于$dW^2$的加权平均计算。
- 超参数$\varepsilon$，如何选择影响都不大，Adam论文的作者推荐使用$10^{-8}$作为默认值。
- 在使用Adam算法的时候，业内通常对$\beta_1$、$\beta_2$以及$\varepsilon$都直接使用默认值，然后尝试不同的学习率$\alpha$来以获得最好的训练效果。

### 学习速率衰减
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%AD%A6%E4%B9%A0%E7%8E%87%E8%A1%B0%E5%87%8F1.JPG" width="80%" height="80%"> 学习速率衰减，即逐渐地减小学习率，可使得学习算法运行更快：
- 如图，当采用小批量梯度下降法进行迭代时：
 - 当学习率$\alpha$采用固定值，会逐步向最小值靠近，但不会完全收敛到这点。如图中蓝色曲线所示。
 - 当采用学习率衰减，那么在初始阶段，因为学习率$\alpha$取值还比较大，学习速度仍然可以比较快。但随着学习率降低$\alpha$变小，步长也会渐渐变小。所以，最终将围绕着离极小值点更近的区域摆动，即使继续训练下去也不会漂游远离。如图中绿色曲线所示。
 
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%AD%A6%E4%B9%A0%E7%8E%87%E8%A1%B0%E5%87%8F2.JPG" width="80%" height="80%">
- 如图所示，可由以下公式，实现学习率衰减：
 - $$\alpha=\frac{1}{1+decay \_ rate*epoch}\alpha_0$$
 - 其中，deacy_rate是参数（可调），epoch是周期数。随着epoch增加，$\alpha$会不断变小。
 
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%AD%A6%E4%B9%A0%E7%8E%87%E8%A1%B0%E5%87%8F3.JPG" width="50%" height="50%"> 实现学习率衰减还有其它可供选择的计算公式，如图所示:
- $\alpha=0.95^{epoch}\cdot \alpha_0$
- $\alpha=\frac{k}{\sqrt{epoch}}\cdot \alpha_0\ \ \ \ or\ \ \ \ \frac{k}{\sqrt{t}}\cdot \alpha_0$
- 离散阶梯衰减。
- 手动衰减。

另外：
- **学习率衰减的确可以帮助加速训练，但学习率衰减通常位于应该尝试的事情中比较靠后的位置**。
- **设置一个固定数值的$\alpha_0$，且使得优化良好，对结果有着巨大影响**。
- 下周，将对超参数进行系统地讲解。

### 局部最优解的问题
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%B1%80%E9%83%A8%E6%9C%80%E4%BC%98%E8%A7%A31.JPG" width="80%" height="80%">
- 在深度学习的早期阶段，人们常常担心优化算法会陷入糟糕的局部最优解(Local Optima)之中。但随着深度学习理论的发展，我们对局部最优的理解也在改变。
- 在使用梯度下降算法不断减小代价函数时，可能会得到局部最优解而不是全局最优解。之前我们对局部最优解的理解是如上图左边所示。
- 但对于神经网络，其参数维数很高，梯度为零的点，在每个方向上，有可能是凸函数，有可能是凹函数。因此，梯度为零的点很可能都是右边所示的马鞍状的鞍点。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%B1%80%E9%83%A8%E6%9C%80%E4%BC%98%E8%A7%A32.JPG" width="80%" height="80%"> 总结：
- 局部最优不是问题，不太可能陷入极差的局部最优问题中（只要训练的是一个较大的神经网络，即有很多参数，代价函数$J$定义在一个相对高维的空间上时）。
-  停滞区让学习过程变得相当慢。
 - 解释：停滞区指的是导数长时间接近于零的一段区域，因为梯度为零或接近于零，曲面很平。在离开停滞区继续下降之前，需要花费很长的时间，缓慢地渡过在停滞区。
 - 解决方法：更复杂的算法，比如Adam算法，可以加快沿停滞区向下移动然后离开停滞区的速度。
 
# 3.超参数调试、批量归一化以及编程框架
## 3.1 超参数调试
### 调试过程
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%951.JPG" width="80%" height="80%"> 深度神经网络需要调试的超参数较多，包括：
- $\alpha$ ：学习速率
- $\beta$ ：动量梯度下降因子
- $\beta_1,\beta_2,\varepsilon$ ：Adam算法参数
- \#layers：神经网络层数
- \#hidden units：各隐藏层神经元个数
- learning rate decay：学习速率衰减参数
- mini-batch size：每一mini-batch包含的样本个数

对于以上超参数的优先级：
- 优先级1：学习速率$\alpha$需要调试的超参数中最重要的一个，没有之一。
- 优先级2：接下来会调整动量梯度下降参数$\beta$，0.9是不错的默认值；还会调整Mini-Batch的大小，来保证最优化算法的运行效率；还经常调试隐藏单元数量。这三个超参数的重要性仅次于学习速率$\alpha$。
- 
优先级3：网络层数有时候对结果起到重要作用，学习率衰减有时也一样。
- 优先级4：当使用Adam优化算法时，几乎不调节$\beta_1,\beta_2,\varepsilon$，几乎都是用0.9，0.999和$10^{-8}$。
 
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%952.JPG" width="80%" height="80%"> 当调整超参数时，对于超参数值的组合：
- 在早期的机器学习算法中，如果有两个超参数（超参数1和超参数2），人们经常会像这样：在一个网格中对点进行规则抽样，然后系统化地尝试这些点所代表的值。如在图中5*5的网格中采样25个点后，选择最优的超参数。当超参数的数量相对较少时，这样的取参方法较为实用。 
- 但在深度学习中，推荐采取另一种方法：在网格中进行随机抽样，无论最重要的超参数是哪个，将帮助你更充分地为最重要的超参数尝试尽可能多的值的组合。超参数值域的随机抽样，能更有效地搜索超参数空间。如图中，随机采样25个点，然后在这些随机选取的点中，尝试所有的超参数。对于多维情况，也是如此在多维空间中进行随机采样，然后尝试多个超参数的组合值。
 - 这样做的原因：事先很难知道，哪一个超参数对于你的模型更重要。  
 - 解释：假设超参数1是学习速率$\alpha$，超参数2是Adam优化算法中的$\varepsilon$。若在网格中取样，因为$\varepsilon$对结果没有什么影响，所以训练了25个模型，但是只相当于尝试了5个有用的α的值；相比较而言，如果在网格中随机取样 那么将获得25个不同的学习速率$\alpha$，因此你找到理想值的概率也就变得更大。 
 
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%953.JPG" width="80%" height="80%"> 由粗糙到精细的搜索策略：
- 继续以二维空间为例，当在此空间进行完随机采样后，发现在某些点能产生最好的结果，大体能确定这个区域内取的值能产生最优结果，即最理想的超参数来自于这个区域。即在对整个框定范围进行粗略的抽样后，结果会引导你集中在一个更小的区域内。
- 然后，继续采用区域定位的抽样方案：即在这个更小的区域内进行密度更高的随机抽样。

### 用合适的尺度去选择超参数
上一节讲解的超参数值域的随机抽样，能帮助更有效地搜索超参数空间。但随机抽样并不意味着在有效值范围内的均匀随机抽样(sampleing uniformly at random)。相反，更重要的是选取适当的尺度(scale)，用以研究这些超参数。
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E8%B6%85%E5%8F%82%E6%95%B0%E6%90%9C%E7%B4%A2%E5%B0%BA%E5%BA%A61.JPG" width="80%" height="80%">
- 对于超参数#layers和#hidden units，采用均匀随机抽样是合理的方案，但它并不是对所有的超参数都适用。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E8%B6%85%E5%8F%82%E6%95%B0%E6%90%9C%E7%B4%A2%E5%B0%BA%E5%BA%A62.JPG" width="80%" height="80%">
- 对于超参数学习率$\alpha$，待调范围是$[0.0001, 1]$。如果使用均匀随机抽样，那么有90%的采样点分布在$[0.1, 1]$之间，只有10%分布在$[0.0001, 0.1]$之间，并不合理。
- 更合理的方法：在对数尺度(log scale)上进行采样，而不是用线性尺度(linear scale)。即分为$[0.0001, 0.001]，[0.001, 0.01]，[0.01, 0.1]，[0.1, 1]$这几个区间。
- 一般解法是，如果线性区间为$[a,b]$，令$m=log(a)$，$n=log(b)$，则对应的$log$区间为$[m,n]$。对$log$区间的$[m,n]$进行随机均匀采样，然后得到的采样值$r$，最后反推到线性区间，即$10^r$。$10^r$就是最终采样的超参数。相应的Python代码为：
```Python
m = np.log10(a)
n = np.log10(b)
r = np.random.rand() #[0,1)
r = m + (n-m)*r #[m,n)
r = np.power(10,r)
```

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E8%B6%85%E5%8F%82%E6%95%B0%E6%90%9C%E7%B4%A2%E5%B0%BA%E5%BA%A63.JPG" width="80%" height="80%">
- 除了$\alpha$之外，动量梯度下降法中的参数$\beta$在超参数调试时，同样应在对数尺度上进行采样。
- 一般$\beta$的取值范围在$[0.9, 0.999]$之间，那么$1-\beta$的取值范围就在$[0.001, 0.1]$之间。那么直接对$1-\beta$在$[0.001, 0.1]$区间内进行对数尺度采样(即$10^r$)，然后再推出$\beta$(即$1-10^r$)即可。
- 为什么$\beta$也需要向$\alpha$那样做非均匀采样:公式$\frac{1}{1-\beta}$在当$\beta$趋于1时，它对$\beta$的值的改变非常敏感。

最后：
- 如果对于某个超参数你选择的尺度是不对的，或即使在存在更优尺度的情况下，你依然选择了均匀尺度(uniform scale) 你仍然可能得到不错的结果，尤其是如果你采取从粗到精(coarse to fine)的搜索策略。

### 实践中的超参数调试：Pandas vs. Caviar
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%951.JPG" width="80%" height="80%">
- 经过调试选择完最佳的超参数并不是一成不变的，一段时间之后（例如一个月），需要根据新的数据和实际情况（如数据集改变、有了更先进的服务器等），再次调试超参数，以获得实时的最佳模型。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%952.JPG" width="80%" height="80%">
- 精心照料一个模型("Panda" approach)：受计算能力所限，只能对一个模型进行训练，调试不同的超参数，使得这个模型有最佳的表现。 
- 并行训练多个模型("Caviar" approach)：可以对多个模型同时进行训练，每个模型上调试不同的超参数，根据表现情况，选择最佳的模型。

## 3.2 批量归一化 
### 归一化网络的激活函数
在深度学习不断兴起的过程中,最重要的创新之一是一种叫批量归一化(Batch Normalization)的算法，可让超参搜索变得很简单，让神经网络对于超参数的选择上不再那么敏感，并且可以更容易地训练非常深的网络 。
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%89%B9%E9%87%8F%E6%A0%87%E5%87%86%E5%8C%961.JPG" width="80%" height="80%"> 批量归一化原理：
- 对于单一逻辑回归神经元，归一化输入的操作：$X=\frac{X-\mu}{\sqrt{\sigma^2}}$，提高模型的训练速度。
- 批量归一化：对$A^{[l-1]}$进行归一化处理，提高$W^{[l]}$和$b^{[l]}$的训练速度。
- 批量归一化在实际操作时，归一化的不是$A^{[i]}$，而是$Z^{[i]}$，即激活函数前的值。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%89%B9%E9%87%8F%E6%A0%87%E5%87%86%E5%8C%962.JPG" width="80%" height="80%"> 单隐藏层的批量归一化的实现：
- 对第$l$层隐藏层的输入`$Z^{[l-1]}=[z^{[l-1](1)},z^{[l-1](2)},...,z^{[l-1](m)}]$`做如下归一化处理，忽略上标$[l-1]$：
 - $\mu=\frac1m\sum_iz^{(i)}$
 - $\sigma^2=\frac1m\sum_i(z_i-\mu)^2$
 - $z^{(i)}_{norm}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^2+\varepsilon}}$
 - 其中，$m$是单个mini-batch包含样本个数，$\varepsilon$是为了防止分母为零，可取值$10^{-8}$。这样，使得该隐藏层的所有输入 $z^{(i)}$均值为0，方差为1。
- 但是，大部分情况下并不希望所有的$z^{(i)}$均值都为0，方差都为1，也不太合理。通常需要对$z^{(i)}$进行进一步处理：
 - $\tilde z^{(i)}=\gamma\cdot z^{(i)}_{norm}+\beta$
 - 式中，$\gamma$和$\beta$是可学习的参数，类似于$W$和$b$一样，可以通过梯度下降等算法求得。这里，$\gamma$和$\beta$的作用是让$\tilde z^{(i)}$的均值和方差为任意值，只需调整其值就可以了。
 - 例如，令：$\gamma=\sqrt{\sigma^2+\varepsilon}$,$\beta=\mu$，则$\tilde z^{(i)}=z^{(i)}$。可见，设置$\gamma$和$\beta$为不同的值，可以得到任意的均值和方差。
- 这样，通过批量归一化，对隐藏层的各个`$z^{[l](i)}$`进行归一化处理，得到`$\tilde z^{[l](i)}$`，替代`$z^{[l](i)}$`。
- 值得注意的是，**输入层的归一化处理和隐藏层的归一化处理是有区别的**。**归一化输入使所有输入的均值为0，方差为1**。而**隐藏层的归一化处理可使各隐藏层输入的均值和方差为任意值**。实际上，从激活函数的角度来说，如果各隐藏层的输入均值在靠近0的区域即处于激活函数的线性区域，则无法更好的利用激活函数非线性的特性，而不是所有的值都集中在线性区域。这就是为什么通过设置$\gamma$和$\beta$来控制`$z^{[l](i)}$`在希望的范围内，或者说**批量归一化真正实现的是通过两个参数$\gamma$和$\beta$来让隐藏单元有可控的均值和方差**。

### 将批量归一化用于神经网络
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84BatchNorm%E5%AE%9E%E7%8E%B01.JPG" width="80%" height="80%"> 对于$L$层神经网络，实施批量归一化的整体流程如下：
- <img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%89%B9%E9%87%8F%E6%A0%87%E5%87%86%E5%8C%96%E6%B5%81%E7%A8%8B.jpg" width="100%" height="100%">
- 其中，参数为$W^{[1]}$,$b^{[1]}$,$W^{[2]}$,$b^{[2]}$,...,$W^{[L]}$,$b^{[L]}$以及$\beta^{[1]}$,$\gamma^{[1]}$,$\beta^{[2]}$,$\gamma^{[2]}$,...,$\beta^{[L]}$,$\gamma^{[L]}$。$\beta^{[l]}$与$\gamma^{[l]}$的学习同$W^{[l]}$与$b^{[l]}$一样，采用梯度下降法。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84BatchNorm%E5%AE%9E%E7%8E%B02.JPG" width="80%" height="80%"> 在mini-batch上应用批量归一化：
- 分别用每个mini-batch的数据(均值和方差)进行批量归一化。
- 因为批量归一化对各隐藏层$Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}$有去均值的操作，所以这里的常数项$b^{[l]}$可以消去，其数值效果完全可以由$\tilde Z^{[l]}$中的$\beta^{[l]}$来实现。因此，我们在使用批量归一化的时候，可以忽略各隐藏层的常数项$b^{[l]}$。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84BatchNorm%E5%AE%9E%E7%8E%B03.JPG" width="80%" height="80%"> 概述了应用批量归一化时，梯度下降(或动量或RMSprop或Adam)的整个过程。

### 批量归一化为什么有效
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%89%B9%E9%87%8F%E6%A0%87%E5%87%86%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%95%881.JPG" width="80%" height="80%"> <img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%89%B9%E9%87%8F%E6%A0%87%E5%87%86%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%95%882.JPG" width="80%" height="80%"> <img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%89%B9%E9%87%8F%E6%A0%87%E5%87%86%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%95%883.JPG" width="80%" height="80%">
- 解释1：归一化输入，使得输入$X$的均值为0，方差为1，大幅加速学习过程。批量归一化同理。
- 解释2：批量归一化使得网络的每一层相对独立。
- 解释3：批量归一化具有轻微的正则化效果。

### 在测试阶段使用批量归一化
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E5%9C%A8%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5%E4%BD%BF%E7%94%A8BatchNorm.JPG" width="50%" height="50%"> 
- 首先，回顾批量归一化在训练过程中，在每一mini-batch，在网络的每一层中，做如下操作：
 - $\mu=\frac1m\sum_iz^{(i)}$
 - $\sigma^2=\frac1m\sum_i(z^{(i)}-\mu)^2$
 - $z_{norm}^{(i)}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^2+\varepsilon}}$
 - $\tilde z^{(i)}=\gamma\cdot z^{(i)}_{norm}+\beta$ 
 - 其中，$\mu$和$\sigma^2$是对单个mini-batch中所有$m$个样本求得的。
- 在测试阶段，如果只有一个样本，求其均值和方差是没有意义的，就需要对$\mu$和$\sigma^2$进行估计。实际应用中一般采用指数加权平均（exponentially weighted average）的方法来预测测试过程单个样本的$\mu$和$\sigma^2$：
 - 指数加权平均的做法:对于第$l$层隐藏层，考虑所有mini-batch在该隐藏层下的$\mu^{[l]}$和$\sigma^{2[l]}$，然后用指数加权平均的方式来预测得到当前单个样本的$\mu^{[l]}$和$\sigma^{2[l]}$。这样就实现了对测试过程单个样本的均值和方差估计。
 - 最后，再利用训练过程得到的$\gamma$和$\beta$值计算出各层的$\tilde z^{(i)}$值。

## 3.3 多类别分类
### Softmax回归
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/Softmax1.JPG" width="80%" height="80%"> 
- 用神经网络进行多分类，`$C=\#class=4$`，0为其他，1为猫，2为狗，3为小鸡。
- 对于单个输入样本$x$，网络的最后一层(第$L$层)为Softmax层，$\hat{y}=a^{[L]}$，维度为$(4,1)$。
- Softmax层中各神经元的输出依次代表$P(other|x)$，$P(cat|x)$，$P(dog|x)$，$P(baby \ chicks|x)$。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/Softmax2.JPG" width="80%" height="80%">
- Softmax层的激活函数计算过程如下：
 - `$z^{[L]}=W^{[L]}a^{[L-1]}+b^{[L]}$`
 - `$t=e^{(z^{[L]})}$`
 - `$a^{[L]}=\frac{e^{z^{[L]}}}{\sum_{i=1}^C t_i}$`
 - `$a^{[L]}_i=\frac{t_i}{\sum_{i=1}^C t_i}$`
 - 也可看成是$a^{[L]}=g^{[L]}(z^{[L]})$，只不是该激活函数的输入是向量，输入也是向量。
 - 其中，Softmax层每个神经元的输出`$a^{[L]}_i$`对应属于该类的概率，满足：`$\sum_{i=1}^Ca^{[L]}_i=1$`
 - `$a^{[L]}= \hat{y}$`，维度为$(C, 1)$。
- 具体计算示例如图。
 
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/Softmax3.JPG" width="80%" height="80%">
- 上图为没有隐藏层，只有单一Softmax层的神经网络，其经Softmax分类的效果如图所示，为线性多分类效果，各两类之间的决策边界均为线性。
- 当网络具有很多隐藏层，可构成更复杂的非线性决策边界。

### 训练一个softmax分类器
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AASoftmax%E5%88%86%E7%B1%BB%E5%99%A81.JPG" width="80%" height="80%"> 理解Softmax：
- Softmax回归是Logistic回归向多类别的泛化。
- 当$C=2$时，Softmax回归将简化成Logistic回归。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AASoftmax%E5%88%86%E7%B1%BB%E5%99%A82.JPG" width="80%" height="80%">
- 假设$C=4$，某个样本的预测输出$\hat y$和目标输出(真实值标签)$y$为：
 - $$\hat y=\left[ \begin{matrix} 0.3 \\ 0.2 \\ 0.1 \\ 0.4 \end{matrix} \right]$$
 - $$y=\left[ \begin{matrix} 0 \\ 1 \\ 0 \\ 0 \end{matrix} \right]$$
- Loss function：$L(\hat y,y)=-\sum_{j=1}^4y_j\cdot log\ \hat y_j$
 - 然而，由于只有当$j=2$时，$y_2=1$，其它情况下，$y_j=0$。所以，上式中的$L(\hat y,y)$可以简化为：$L(\hat y,y)=-y_2\cdot log\ \hat y_2=-log\ \hat y_2$
 - 要让$L(\hat y,y)$更小，就应该让$\hat y_2$越大越好。$\hat y_2$反映的是概率，完全符合我们之前的定义。 
- Cost function：$J(W^{[1]},b^{[1]},...)=\frac1m\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})$
- 若对于m个样本，其预测输出向量$A^{[L]}$即$\hat Y$的维度为$(4, m)$，样本标签$Y$的维度也为$(4, m)$。

<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AASoftmax%E5%88%86%E7%B1%BB%E5%99%A83.JPG" width="80%" height="80%"> 梯度下降的过程中，输出层Softmax的梯度推导，即$dZ^{[L]}$的推导：
- $$da^{[L]}=-\frac{1}{a^{[L]}}$$
- $$\frac{\partial a^{[L]}}{\partial z^{[L]}}=\frac{\partial}{\partial z^{[L]}}\cdot (\frac{e^{z^{[L]}_i}}{\sum_{i=1}^Ce^{z^{[L]}_i}})=a^{[L]}\cdot (1-a^{[L]})$$
- $$dz^{[L]}= \frac{\partial J}{\partial z^{[L]}}= da^{[L]}\cdot \frac{\partial a^{[L]}}{\partial z^{[L]}}=a^{[L]}-1=a^{[L]}-y$$
- 对于所有$m$个训练样本：$$dZ^{[L]}=A^{[L]}-Y$$
- 可见$dZ^{[L]}$的表达式与二元分类结果是一致的，虽然推导过程不太一样。然后就可以继续进行反向传播过程的梯度下降算法了，推导过程与二元分类神经网络完全一致。

## 3.4 编程框架介绍
### 深度学习框架
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6.JPG" width="80%" height="80%"> 如图，介绍了目前的深度学习框架，和选择深度学习框架的标准。

### TensorFlow
<img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/tensorflow1.JPG" width="80%" height="80%"> <img src="http://ozruihqgo.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%BE%E7%A8%8B2/tensorflow2.JPG" width="80%" height="80%"> 本节介绍TensorFlow程序的典型结构。

举个例子来说明，代价函数是参数`w`的函数：$J=w^2-10w+25$。
如果使用TensorFlow对代价函数进行优化，求出最小值对应的`w`，程序如下：
```Python
import numpy as np
import tensorflow as tf

w = tf.Variable(0,dtype=tf.float32)
#cost = tf.add(tf.add(w**2,tf.multiply(-10,w)),25)
cost = w**2 - 10*w +25
train = tf.train.GradientDescentOptimizer(0.01).minimize(cost)

init = tf.global_variables_initializer()
session = tf.Session()
session.run(init)
print(session.run(w))
```
`>>0.0`
```Python
session.run(train)
print(session.run(w))
```
`>>0.1`
```Python
for i in range(1000):
    session.run(train)
print(session.run(w))
```
`>>4.99999`
TensorFlow框架内可以直接调用梯度下降优化算法。在运行1000次梯度下降算法后，`w`的解为4.99999，已经非常接近`w`的最优值5了。
针对上面这个例子，如果对`w`前的系数用变量`x`来代替，程序如下：
```Python
import numpy as np
import tensorflow as tf

cofficients = np.array([[1.],[-10.],[25.]])

w = tf.Variable(0,dtype=tf.float32)
x = tf.placeholder(tf.float32,[3,1])
#cost = tf.add(tf.add(w**2,tf.multiply(-10,w)),25)
#cost = w**2 - 10*w +25
cost = x[0][0]*w**2 + x[1][0]*w + x[2][0]
train = tf.train.GradientDescentOptimizer(0.01).minimize(cost)

init = tf.global_variables_initializer()
session = tf.Session()
session.run(init)
print(session.run(w))
```
`>>0.0`
```Python
session.run(train, feed_dict=(x:coefficients))
print(session.run(w))
```
`>>0.1`
```Python
for i in range(1000):
    session.run(train, feed_dict=(x:coefficients))
print(session.run(w))
```
`>>4.99999`
结果跟之前是一样的。除此之外，我们还可以更改`x`即`cofficients`的值，而得到不同的优化结果`w`。
另外，上段程序中的：
```
session = tf.Session()
session.run(init)
print(session.run(w))
```
有另外一种写法：
```Python
with tf.Session() as session:
    session.run(init)
    print(session.run(w))
```
TensorFlow的最大优点就是采用数据流图(data flow graphs)来进行数值运算。图中的节点(Nodes)表示数学操作，图中的线(edges)则表示在节点间相互联系的多维数据数组，即张量(tensor)。而且它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU(或GPU)，服务器，移动设备等。
 